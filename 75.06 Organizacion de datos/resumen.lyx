#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{color}

\titleformat{\section}
{\color{red}\normalfont\Large\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\color{blue}\normalfont\Large\bfseries}{\thesubsection}{1em}{}

\titleformat{\subsubsection}
{\color{cyan}\normalfont\Large\bfseries}{\thesubsubsection}{1em}{}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman default
\font_sans default
\font_typewriter beramono
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Organizacion de Datos"
\pdf_author "Maria Ines Parnisari"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 0
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\footnotesize\ttfamily},commentstyle={\color{blue}},emph={si, //,{,}, +,=,<, >, para, cada, devolver, continuar, en, de},emphstyle={\color{red}},frame=single,keywordstyle={\color{red}},language={C++},numbers=left,numbersep=5pt,stepnumber=1,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
[75.06] Organización de Datos
\end_layout

\begin_layout Author
María Inés Parnisari
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: cómo representar y almacenar datos en archivos para su resguardo, recuperación
 y transmisión de forma eficiente y segura.
\end_layout

\begin_layout Standard

\series bold
Dato
\series default
: representación de un objeto (cosa concreta o abstracta, o evento pasado
 o futuro) en una unidad lógica llamada 
\series bold
registro
\series default
, formado por 
\series bold
campos
\series default
 que describen al objeto (los atributos).
\end_layout

\begin_layout Standard

\series bold
Archivo de datos
\series default
: unidad lógica de almacenamiento permanente de 
\series bold
registros
\series default
, administrada por un 
\series bold
sistema operativo
\series default
.
 Dentro de un archivo los registros pueden agruparse en 
\series bold
bloques
\series default
 o 
\series bold
páginas
\series default
.
\end_layout

\begin_layout Standard

\series bold
Diseño de datos
\series default
: tiene dos etapas que son independientes del lenguaje de programación utilizado.
 
\end_layout

\begin_layout Enumerate

\series bold
Diseño conceptual
\series default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
Bases de Datos: conceptos
\emph default
.
 Silberschatz.
 Capítulo 2.
\end_layout

\end_inset

: implica definir los atributos.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Atributos
\series default
: representan a un dato, y tienen un 
\series bold
valor
\series default
 (que puede ser 
\series bold
nulo
\series default
).
 Cada atributo tiene una lista de valores permitidos (el
\series bold
 dominio
\series default
).
 Pueden ser:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simples.
 
\emph on
Edad
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Obligatorios.
 
\emph on
Nombre y apellido
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Monovalentes.
 
\emph on
Sexo
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID único.
 
\emph on
DNI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compuestos.
 
\emph on
Dirección
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcionales 
\emph on
E-mail
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Polivalentes.
 
\emph on
Teléfonos
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID externos.
 
\emph on
Código postal
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Para cada atributo debe definirse: 
\end_layout

\begin_layout Itemize
Identidad: el nombre.
 
\end_layout

\begin_layout Itemize
Estructura, en caso de que sean compuestos.
 
\end_layout

\begin_layout Itemize
Cardinalidad (
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

 = opcional, 
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

 = ninguno o varios, 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

 = uno o varios) 
\end_layout

\begin_layout Itemize
Extensión 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Diseño lógico
\series default
: implica definir tipos o dominios para atributos, y la forma de almacenamiento
 y recuperación.
\end_layout

\begin_deeper
\begin_layout Enumerate
Tipos de valores: 
\family typewriter
int, float, char, char[], string, boolean, binary
\family default
 
\end_layout

\begin_layout Enumerate
Forma de almacenamiento: registros de longitud fija o registros de longitud
 variable.
 
\end_layout

\end_deeper
\begin_layout Part
Sistemas de archivos
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
Sistemas Operativos Modernos
\emph default
.
 Tanenbaum.
 Capítulo 4.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Sistema operativo
\series default
: responsable de manejar 
\series bold
recursos
\series default
 físicos (hardware) y lógicos (carpetas y archivos).
 Provee una interfaz controlada entre ambos.
\end_layout

\begin_layout Standard
Conceptos de sistemas operativos: 
\end_layout

\begin_layout Itemize

\series bold
Proceso
\series default
: programa en ejecución.
 Tiene asignado un 
\series bold
espacio de direcciones
\series default
.
 El espacio de direcciones contiene el programa ejecutable, los datos del
 programa y su pila.
 Toda la información de cada proceso se almacena en una 
\series bold
tabla de procesos
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
Varios procesos pueden ser instancias de un mismo programa.
 Un sistema que puede ejecutar varios procesos 
\begin_inset Quotes eld
\end_inset

simultáneamente
\begin_inset Quotes erd
\end_inset

 se denomina 
\series bold
multitarea
\series default
.
 En estos sistemas, la CPU le asigna un quantum de tiempo a cada proceso,
 y cuando este tiempo se acaba, se ejecuta otro proceso.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/multitasking.png
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multitasking.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Espacio de direcciones
\series default
: porción de la memoria principal que se le asigna a un proceso.
 Es un mecanismo de protección manejado por el sistema operativo y por el
 hardware.
 
\end_layout

\begin_layout Itemize

\series bold
Archivos y directorios
\series default
: los directorios agrupan archivos u otros directorios.
 La jerarquía de archivos tiene forma de árbol.
 Existe un 
\series bold
directorio raíz
\series default
, y el 
\series bold
directorio actual
\series default
.
 
\end_layout

\begin_layout Standard
Funciones del sistema operativo: 
\end_layout

\begin_layout Enumerate
Identificar y localizar 
\series bold
archivos
\series default
 mediante jerarquía de 
\series bold
directorios
\series default
.
 
\end_layout

\begin_layout Enumerate
Permitir a usuarios o grupos de usuarios establecer 
\series bold
permisos
\series default
 de acceso a archivos.
 
\end_layout

\begin_layout Enumerate
Asignar 
\series bold
espacio
\series default
 en discos, administrando la ocupación y liberación de archivos.
 
\end_layout

\begin_layout Enumerate
Coordinar la relación entre uno o varios procesos en ejecución, y su deseo
 de acceder al mismo dispositivo de almacenamiento simultáneamente (
\series bold
concurrencia
\series default
).
 
\end_layout

\begin_layout Enumerate
Coordinar la comunicación entre la CPU (que maneja tiempos electrónicos
 rápidos) y los dispositivos de almacenamiento (que maneja tiempos mecánicos
 lentos), mediante el uso de 
\series bold
buffers
\series default
.
 
\end_layout

\begin_layout Standard

\series bold
Sistema de archivo
\series default
: parte del sistema operativo que administra los archivos.
 Los sistemas de archivos se almacenan en disco.
\end_layout

\begin_layout Section
Archivos
\end_layout

\begin_layout Standard
Requerimientos para el almacenamiento de información a largo plazo: 
\end_layout

\begin_layout Itemize
Debe ser posible almacenar mucha información.
 
\end_layout

\begin_layout Itemize
La información debe sobrevivir a la terminación del proceso que la utilice.
 
\end_layout

\begin_layout Itemize
Varios procesos deben ser capaces de acceder a la misma información concurrentem
ente.
 
\end_layout

\begin_layout Standard

\series bold
Archivo
\series default
: unidad lógica de información creada por los procesos.
\end_layout

\begin_layout Standard
Estructura de archivos: 
\end_layout

\begin_layout Itemize
Secuencia de bytes: provee la mayor flexibilidad.
 
\end_layout

\begin_layout Itemize
Secuencia de registros de longitud fija.
 
\end_layout

\begin_layout Itemize

\series bold
Árbol
\series default
: formado por registros que tienen un campo 
\series bold
llave.

\series default
 
\end_layout

\begin_layout Standard
Tipos de archivos según la función que cumplen: 
\end_layout

\begin_layout Itemize

\emph on
Archivos regulares
\emph default
: contienen información del usuario.
 Pueden ser 
\series bold
ASCII 
\series default
o binarios.
 
\end_layout

\begin_layout Itemize

\emph on
Archivos especiales de caracteres
\emph default
: modelan dispositivos de E/S.
 
\end_layout

\begin_layout Itemize

\emph on
Archivos especiales de bloques
\emph default
: modelan discos.
 
\end_layout

\begin_layout Itemize

\emph on
Archivos especiales de red
\emph default
: para comunicar procesos.
 
\end_layout

\begin_layout Itemize

\emph on
Directorios
\emph default
: mantienen la estructura del sistema de archivos.
 
\end_layout

\begin_layout Standard
Tipos de archivos según los datos que contienen: 
\end_layout

\begin_layout Enumerate

\series bold
De datos maestros
\series default
.
 Representan cosas reales.
 
\emph on
Ejemplo: un archivo de productos.

\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
Transaccionales
\series default
.
 Representan eventos.
 
\emph on
Ejemplo: un archivo con registros de ventas de productos.

\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De reporte
\series default
: para presentarle a un usuario.
 
\emph on
Ejemplo: 
\begin_inset Quotes eld
\end_inset

.pdf
\begin_inset Quotes erd
\end_inset


\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De trabajo
\series default
: resultados parciales de procesamiento.
 
\emph on
Ejemplo: 
\begin_inset Quotes eld
\end_inset

.tmp
\begin_inset Quotes erd
\end_inset


\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De control de datos:
\series default
 para almacenar metadatos o administrar el acceso a otros archivos.
 
\end_layout

\begin_layout Enumerate

\series bold
De intercambio de datos
\series default
: representan datos de forma estándar para trabajar más fácil entre varias
 aplicaciones.
 
\emph on
Ejemplo: XML.

\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De recursos de programa
\series default
.
 
\emph on
Ejemplo: video, audio, imágenes...

\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De productos de programas
\series default
.
 
\emph on
Ejemplo: 
\begin_inset Quotes eld
\end_inset

.doc
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.xls
\begin_inset Quotes erd
\end_inset

...

\emph default
 
\end_layout

\begin_layout Enumerate

\series bold
De empaquetado de archivos
\series default
.
 
\emph on
Ejemplo: 
\begin_inset Quotes eld
\end_inset

.tar
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.rar
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.zip
\begin_inset Quotes erd
\end_inset

...

\emph default
 
\end_layout

\begin_layout Standard
Posibles atributos de archivos: 
\end_layout

\begin_layout Itemize
Atributos de 
\series bold
protección
\series default
: usuarios permitidos, contraseña, creador, propietario.
 
\end_layout

\begin_layout Itemize
Atributos 
\series bold
bandera
\series default
 (binarios): 
\begin_inset Quotes eld
\end_inset

sólo lectura
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

oculto
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

del sistema
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

de archivo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ascii/binario
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

de acceso aleatorio
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

temporal
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

de bloqueo
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
Atributos 
\series bold
extras
\series default
: longitud de registro, posición de la llave en el registro, longitud de
 la llave, hora de creación, hora de último acceso, hora de última modificación,
 tamaño actual, tamaño máximo.
 
\end_layout

\begin_layout Standard
Operaciones posibles en un archivo:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Create
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Open
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Read
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Seek
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Get attributes
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Rename
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Delete
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Close
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Write
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Append
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set attributes
\family default
 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
Create
\family default
 crea un archivo sin datos y establece algunos atributos.
 
\end_layout

\begin_layout Itemize

\family typewriter
Open
\family default
 lleva los atributos y la lista de direcciones de disco a memoria principal.
 Se debe especificar un modo de apertura.
 
\end_layout

\begin_layout Itemize

\family typewriter
Close
\family default
 obliga a escribir el último bloque del archivo (
\emph on
flush
\emph default
).
 
\end_layout

\begin_layout Itemize

\family typewriter
Read
\family default
 requiere tres parámetros: el 
\emph on
file descriptor 
\emph default
(entero que referencia al archivo), cuántos datos se necesitan leer, y dónde
 colocarlos (un buffer).
 
\end_layout

\begin_layout Itemize

\family typewriter
Rename
\family default
 evita tener que copiar el archivo en otro nuevo con el nuevo nombre.
 
\end_layout

\begin_layout Section
Directorios
\end_layout

\begin_layout Standard
Tipos de directorio: 
\end_layout

\begin_layout Itemize

\emph on
Directorios jerárquicos
\emph default
, son árboles con uno o más niveles.
 
\end_layout

\begin_layout Itemize

\emph on
Directorio de un solo nivel
\emph default
, que puede simular un directorio jerárquico si a los archivos los nombramos
 como si fueran un directorio.
 Ejemplo: 
\begin_inset Quotes eld
\end_inset


\family typewriter
usr/ast/file
\family default

\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Nombres de rutas: 
\end_layout

\begin_layout Itemize

\series bold
Absoluto
\series default
: ruta desde el directorio raíz al archivo.
 
\end_layout

\begin_layout Itemize

\series bold
Relativa
\series default
: se utiliza en conjunto con el directorio de trabajo.
 
\end_layout

\begin_layout Standard
Operaciones posibles en un directorio:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Create dir
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Open dir
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Read dir
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Link
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Rename
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Delete dir
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Close dir
\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Unlink
\family default
 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
\emph on
Link
\series default
\emph default
: llamada al sistema que permite a un archivo aparecer en más de un directorio.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\emph on
Hard link
\series default
\emph default
: relación bidireccional entre una ruta y un archivo.
 Dos rutas apuntan a la misma estructura que contiene metadatos sobre un
 archivo.
\end_layout

\begin_deeper
\begin_layout Standard
En UNIX BSD: Al hacer un 
\emph on
hard link
\emph default
, se incrementa el contador de 
\emph on
hard links
\emph default
 en el nodo-i del archivo.
 Todos los nodos-i tienen, al menos, 1 en su contador.
 Cuando se borra un 
\emph on
hard link
\emph default
, el contador decrece.
 Cuando el contador llega a cero, el archivo se borra definitivamente.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\emph on
Soft link
\series default
 
\series bold
/ symbolic link
\series default
\emph default
: relación unidireccional entre una ruta y un archivo.
\end_layout

\begin_deeper
\begin_layout Standard
En UNIX BSD: La carpeta original (1) apunta al nodo-i del archivo X.
 El siguiente directorio (2) que quiera tener una referencia al archivo,
 crea un archivo que contiene la ruta del archivo original X.
 Si es borra el archivo X, la ruta (2) tiene un puntero inválido.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/hardlinks_softlinks.jpg
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Hard links y soft links.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Los 
\emph on
hard links
\emph default
 no requieren espacio extra en el disco, y los soft links sí.
\end_layout

\begin_layout Standard
Los 
\emph on
soft links
\emph default
 pueden apuntar a archivos en otras máquinas, en la misma red o por Internet.
 Los hard links solo pueden apuntar a archivos dentro de la misma partición.
\end_layout

\end_deeper
\begin_layout Section
Distribución del sistema de archivos
\end_layout

\begin_layout Standard
Ejemplo: UNIX BSD.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/file system distribution.png
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Distribución posible de un sistema de archivos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
MBR
\series default
 (
\emph on
Master Boot Record
\emph default
): se utiliza para arrancar la computadora.
 
\end_layout

\begin_layout Enumerate

\series bold
Tabla de particiones
\series default
: proporciona las direcciones de inicio y fin de cada partición.
 Proporciona el nombre de la partición activa.
 
\end_layout

\begin_layout Enumerate
Para cada partición:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Boot block
\series default
: contiene el módulo de arranque del sistema operativo de esa partición.
 
\end_layout

\begin_layout Enumerate

\series bold
Superblock
\series default
: contiene todos los parámetros clave acerca del sistema de archivos.
 
\end_layout

\begin_layout Enumerate
Administración del 
\series bold
espacio libre
\series default
: información acerca de los bloques libres, en forma de 
\emph on
bitmap
\emph default
 o una lista de punteros.
 
\end_layout

\begin_layout Enumerate

\series bold
Nodos-i
\series default
: arreglo de estructuras de datos, uno por archivo, que indica todo acerca
 del archivo.
 La cantidad de nodos-i es 
\series bold
fija
\series default
, y se establece al crear la partición.
 
\end_layout

\begin_layout Enumerate
Directorio raíz.
 
\end_layout

\begin_layout Enumerate
Todos los otros directorios y archivos.
 
\end_layout

\end_deeper
\begin_layout Section
Implementación de archivos
\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: mantener un registro acerca de qué bloques del disco van con cuál archivo.
 
\end_layout

\begin_layout Standard
Formas: 
\end_layout

\begin_layout Enumerate

\series bold
Asignación contigua
\series default
: almacenar cada archivo como una serie contigua de bloques de disco.
 Cada archivo comienza al inicio de un nuevo bloque, y puede desperdiciarse
 espacio en el último bloque de cada archivo.
\end_layout

\begin_deeper
\begin_layout Standard
Ventajas: 
\end_layout

\begin_layout Enumerate
Es simple de implementar.
 Sólo hay que 
\series bold
guardar
\series default
, por cada archivo, 
\series bold
la dirección de disco del primer bloque y la cantidad de bloques que ocupa
\series default
.
 
\end_layout

\begin_layout Enumerate
El 
\series bold
rendimiento de lectura
\series default
 es excelente.
 El archivo completo se puede leer en una sola operación.
 
\end_layout

\begin_layout Standard
Desventajas: 
\end_layout

\begin_layout Enumerate
Con el tiempo, el disco se 
\series bold
fragmenta
\series default
.
 Cuando se quita un archivo quedan bloques libres, y no se pueden compactar
 en el momento.
\end_layout

\begin_deeper
\begin_layout Standard
Solución posible: mantener una lista de bloques libres.
\end_layout

\begin_layout Standard
Problema de esta solución: cuando se cree un archivo nuevo será necesario
 conocer su tamaño final para poder elegir el hueco apropiado.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Asignación de lista enlazada
\series default
: cada archivo es una lista enlazada de bloques de disco.
 La primera palabra del primer bloque del archivo se usa como puntero al
 próximo bloque, hasta llegar a un puntero inválido (fin de archivo).
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/asignacion de lista enlazada.png
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Asignación de lista enlazada.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ventajas: 
\end_layout

\begin_layout Enumerate

\series bold
No se produce fragmentación
\series default
, porque cada bloque se puede aprovechar.
 
\end_layout

\begin_layout Enumerate
La entrada del directorio se reduce a almacenar, para cada archivo, la 
\series bold
dirección de disco del primer bloque
\series default
.
 
\end_layout

\begin_layout Standard
Desventajas: 
\end_layout

\begin_layout Enumerate
La lectura aleatoria es 
\series bold
lenta
\series default
.
 Para llegar al bloque 
\begin_inset Formula $n$
\end_inset

, se necesita leer los 
\begin_inset Formula $n-1$
\end_inset

 bloques anteriores.
 
\end_layout

\begin_layout Enumerate
El puntero ocupa mucho 
\series bold
espacio
\series default
.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
FAT / Asignación de lista enlazada utilizando una tabla en memoria
\series default
: misma estructura anterior, pero los punteros de cada bloque del disco
 se almacenan en una tabla en memoria.
 Esta tabla contiene tantas entradas como bloques de disco haya.
 Cada entrada posee un puntero al bloque siguiente del archivo.
\end_layout

\begin_deeper
\begin_layout Standard
Además se tiene un directorio que, para cada archivo, tiene el número del
 bloque inicial.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/fat.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
FAT.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ventajas: 
\end_layout

\begin_layout Enumerate
El bloque completo contiene datos.
 
\end_layout

\begin_layout Enumerate
La lectura aleatoria es mucho más rápida, porque la lista enlazada está
 en memoria.
 
\end_layout

\begin_layout Standard
Desventajas: 
\end_layout

\begin_layout Enumerate
Toda la tabla debe estar en la memoria todo el tiempo.
 Con un disco de 200 GB, se requiere una FAT que ocupa 600 MB en memoria.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Nodos-i
\series default
: cada archivo y cada directorio tiene asociado una estructura de datos
 llamada 
\series bold
nodo-i
\series default
.
 Estos son registros de 
\series bold
longitud fija
\series default
 con los siguientes campos
\begin_inset Foot
status open

\begin_layout Plain Layout
El nombre del archivo NO es un campo del nodo-i.
 Se guarda en la entrada del directorio.
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Propietario y grupo del propietario, 
\end_layout

\begin_layout Enumerate
Tipo de archivo (regular, directorio, de caracteres, de red, de bloque)
 
\end_layout

\begin_layout Enumerate
Permisos de acceso (9 bits), 
\end_layout

\begin_layout Enumerate
Fechas de acceso y modificación, 
\end_layout

\begin_layout Enumerate
Cantidad de registros del directorio que referencian al nodo-i (contador
 de 
\emph on
hardlinks
\emph default
)
\end_layout

\begin_layout Enumerate
Tamaño del archivo en bytes, 
\end_layout

\begin_layout Enumerate
Lista de bloques de almacenamiento del archivo:
\end_layout

\begin_deeper
\begin_layout Enumerate
Bloques 0 a 9 contienen direcciones directas 
\end_layout

\begin_layout Enumerate
Bloque 10 contiene dirección indirecta simple 
\end_layout

\begin_layout Enumerate
Bloque 11 contiene dirección indirecta doble 
\end_layout

\begin_layout Enumerate
Bloque 12 contiene dirección indirecta triple 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/inode-detail.jpg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Nodo-i
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cada vez que un archivo cambia, cambia su correspondiente nodo-i.
 Pero si el contenido del nodo-i cambia, no necesariamente cambiará el archivo
 también.
\end_layout

\begin_layout Standard
La copia de un nodo-i a memoria contiene, además de los campos ya mencionados,
 los siguientes: 
\end_layout

\begin_layout Itemize
Estado del nodo-i en memoria (
\begin_inset Quotes eld
\end_inset

bloqueado/desbloqueado
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

proceso esperando por el nodo-i
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

la copia en memoria es distinta a la que está en el disco por un cambio
 en el nodo-i
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

la copia en memoria es distinta a la que está en el disco por un cambio
 en los datos del archivo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

el archivo es un punto de montaje
\begin_inset Quotes erd
\end_inset

), 
\end_layout

\begin_layout Itemize
Número de dispositivo que contiene al archivo, 
\end_layout

\begin_layout Itemize
Número de nodo-i, 
\end_layout

\begin_layout Itemize
Punteros a otros nodos-i en memoria (el sistema encadena los nodos-i en
 memoria de igual forma que los buffers de bloques), 
\end_layout

\begin_layout Itemize
Contador que indica el número de instancias del archivo que están activas.
\end_layout

\begin_deeper
\begin_layout Standard
Cuando este contador llega a 0, el nodo-i se libera y se lo agrega a la
 lista de nodos-i libres.
\end_layout

\end_deeper
\begin_layout Standard
Ventajas: 
\end_layout

\begin_layout Enumerate
El nodo-i necesita estar en memoria
\series bold
 solo cuando está abierto el archiv
\series default
o.
 Si cada nodo-i ocupa 
\begin_inset Formula $n$
\end_inset

 bytes, y el máximo de archivos abiertos es 
\begin_inset Formula $k$
\end_inset

, la memoria total ocupada por los nodos-i es 
\begin_inset Formula $nk$
\end_inset

 bytes.
 
\end_layout

\begin_layout Standard
Desventajas: 
\end_layout

\begin_layout Enumerate
El número del nodo-i es simplemente un índice a un sector del disco que
 contiene al nodo-i en sí.
 Por lo tanto, hay una ca
\series bold
ntidad fija de nodos-i posibles
\series default
.
 
\end_layout

\end_deeper
\begin_layout Section
Implementación de directorios
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Implementación de archivos mediante...

\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Asignación contigua
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Asignación de lista enlazada (en disco y en memoria)
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Nodos-i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Entrada de directorio debe contener...

\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nombre de archivo + Dirección de disco del primer bloque + Cantidad de bloques
 que ocupa el archivo 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nombre de archivo + Dirección de disco del primer bloque 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nombre de archivo + 
\series bold
Número
\series default
 del nodo-i del archivo.
\end_layout

\begin_layout Plain Layout
El directorio raíz suele ser el nodo-i 0.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Para leer un archivo...
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/unix_pathname_resolution.png
	scale 23

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Asignación de espacio en disco
\end_layout

\begin_layout Standard
El disco se divide en bloques.
 Cada archivo puede ocupar uno o más bloques.
 Hay que tomar ciertas decisiones: 
\end_layout

\begin_layout Enumerate

\emph on
¿Bloques contiguos o no?
\emph default
 Si son contiguos se genera fragmentación externa, aunque la lectura es
 más veloz.
 
\end_layout

\begin_layout Enumerate

\emph on
¿Tamaño del bloque?
\emph default
 Si son muy grandes, perdemos espacio por fragmentación interna.
 Si son muy chicos, perdemos tiempo al buscar cada bloque.
\end_layout

\begin_deeper
\begin_layout Standard
En general se eligen bloques desde 1 KB hasta 4 KB.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
¿Cómo registramos los bloques libres?
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Lista enlazada de bloques libres
\series default
, donde cada bloque contiene tantos números de bloques de disco libres como
 pueda.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
Ejemplo: un bloque de disco de 1 KB puede contener 256 números de bloque
 de disco de 32 bits.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Lista enlazada de bloques libres contiguos
\series default
, donde cada bloque contiene un número de bloque libre + la cantidad de
 bloques libres que le siguen a ese.
 
\end_layout

\begin_layout Enumerate

\series bold
Mapa de bits de bloques libres
\series default
.
 Un 1 representa 
\begin_inset Quotes eld
\end_inset

bloque libre
\begin_inset Quotes erd
\end_inset

, un 0 representa 
\begin_inset Quotes eld
\end_inset

bloque ocupado
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
El mapa de bits requiere menos espacio excepto cuando hay pocos bloques
 libres.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
¿Como aseguramos la consistencia del sistema de archivos?
\end_layout

\begin_deeper
\begin_layout Standard
Se pueden realizar dos tipos de verificaciones de consistencia: 
\end_layout

\begin_layout Enumerate

\series bold
Consistencia de bloques
\series default
: se crean dos tablas, con una entrada por cada bloque de disco.
 Una tabla contiene los bloques en uso (hay que recorrer todos los nodos-i),
 la otra tabla contiene los bloques libres (hay que recorrer todo el mapa
 de bits o la lista enlazada de bloques libres).
\end_layout

\begin_deeper
\begin_layout Standard
Si el sistema de archivos es consistente, cada bloque tendrá un 1 en la
 primera tabla o en la segunda.
 Si no es consistente, puede deberse a varios motivos: 
\end_layout

\begin_layout Itemize

\emph on
Bloque faltante
\emph default
 (contador 0 en ambas tablas): no está en uso ni libre.
 Solución: marcarlo como libre.
 
\end_layout

\begin_layout Itemize

\emph on
Bloque doblemente libre
\emph default
 (contador 2 en tabla de libres).
 Solución: reconstruir la lista de bloques libres.
 
\end_layout

\begin_layout Itemize

\emph on
Bloque doblemente ocupado
\emph default
 (contador 2 en tabla de ocupados).
 Solución: copiar el bloque en otro, e insertar la copia en uno de los archivos.
 Es muy probable que uno de los archivos termine con basura, así que se
 lo debe reportar al usuario.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Consistencia de directorios
\series default
: se crea una tabla de contadores por archivo.
 Se inspecciona cada directorio, aumentando el contador cada vez que aparece
 el archivo.
 (Los hard links cuentan pero los soft links no).
 Cuando el verificador termina, la tabla está indexada por número de nodo-i.
 Después se comparan estos contadores con las cuentas de vínculos almacenadas
 en los mismos nodos-i.
\end_layout

\begin_deeper
\begin_layout Standard
Si el sistema de archivos es consistente, ambas cuentas concordarán.
 Si no es consistente, puede deberse a dos motivos: 
\end_layout

\begin_layout Itemize
Cuenta de vínculos del nodo-i 
\begin_inset Formula $>$
\end_inset

 valor en tabla: reestablecer valor en el nodo-i.
 
\end_layout

\begin_layout Itemize
Cuenta de vínculos del nodo-i 
\begin_inset Formula $<$
\end_inset

 valor en tabla: reestablecer valor en el nodo-i.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Concurrencia
\end_layout

\begin_layout Standard
Los pedidos de acceso al disco se especifican mediante el número de bloque
 que se necesita, y los niveles más bajos del sistema de archivos se encargan
 de convertir este número en 
\begin_inset Quotes eld
\end_inset

cilindro, cara, sector
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
El 
\series bold
algoritmo del ascensor
\series default
 es un 
\series bold
técnica de optimización de los accesos al disco
\series default
 que consiste en 
\series bold
reducir los movimientos de cambio de pista
\series default
.
\end_layout

\begin_layout Standard
Su nombre se deriva del comportamiento de un ascensor: mientras está ocupado,
 el ascensor viaja en una sola dirección (arriba o abajo); solo se detiene
 para dejar gente afuera o recoger nuevas personas.
\end_layout

\begin_layout Standard

\emph on
Funcionamiento
\emph default
: 
\end_layout

\begin_layout Enumerate
Si el disco está desocupado y si hay una petición de lectura o escritura:
\end_layout

\begin_deeper
\begin_layout Enumerate
El brazo del disco se mueve hacia dentro o hacia afuera, hacia el cilindro
 buscado.
 
\end_layout

\begin_layout Enumerate
Si llega otra petición:
\end_layout

\begin_deeper
\begin_layout Enumerate
Si el nuevo cilindro buscado se encuentra en la dirección a la que viaja
 el brazo del disco, se lo lee / escribe.
 
\end_layout

\begin_layout Enumerate
Si no, se espera a que el brazo llegue al borde del plato, se le invierte
 la dirección, y se procede con la petición.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Optimización de rendimiento: buffers y cachés
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
Bases de Datos: Conceptos.
 Silberschatz
\emph default
.
 Capítulo 11, sección 4 y 5.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Buffer
\series default
: sección de la memoria principal disponible para almacenar copias de bloques
 del disco, que luego se escribirán en él.
 Esta sección puede no ser suficiente para almacenar todos los bloques de
 un archivo, por lo que se necesita administrar el buffer.
 
\end_layout

\begin_layout Itemize
Es muy común que el sistema utilice varios buffers para realizar la E/S
 de un programa (al menos dos: uno para la lectura, y otro para la escritura).
 
\end_layout

\begin_layout Itemize

\series bold
\emph on
Multiple buffering
\series default
\emph default
: procedimiento mediante el cual dos buffers intercambian sus roles luego
 de una tarea de lectura o escritura.
 Esto permite al sistema operativo trabajar con un buffer mientras el otro
 se está cargando del disco o vaciando hacia el disco.
 
\end_layout

\begin_layout Itemize
Reemplazo de buffers: cuando se necesita una parte de buffer y no hay lugar,
 hay varias técnicas para mandar bloques al disco y hacer lugar:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
LRU
\series default
 (
\emph on
Least Recently Used
\emph default
) para mandar el bloque que se utilizó primero al disco.
 
\end_layout

\begin_layout Itemize

\series bold
MRU
\series default
 (
\emph on
Most Recently Used
\emph default
) para mandar el bloque que se utilizó último al disco.
 
\end_layout

\end_deeper
\begin_layout Itemize
Bloques sujetados (
\emph on
pinned
\emph default
 
\emph on
blocks
\emph default
): son bloques que están en el buffer y que no tienen permitido escribirse
 en el disco.
 
\end_layout

\begin_layout Standard
El acceso al disco es un millón de veces más lento que a la memoria.
 Por ello, existen optimizaciones para mejorar el rendimiento: 
\end_layout

\begin_layout Enumerate

\series bold
Uso de caché
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
\begin_inset CommandInset label
LatexCommand label
name "enu:Buffer-cach=0000E9:-estructura"

\end_inset

Buffer caché
\series default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
The Design of the UNIX Operating System.

\emph default
 Capítulo 3.
\end_layout

\end_inset

: estructura de software cuyo objetivo es minimizar los accesos a disco.
 Agrupa una colección de bloques que se leyeron del disco y se mantienen
 en memoria.
\end_layout

\begin_layout Standard
El sistema de 
\emph on
buffers
\emph default
 de UNIX consta de dos partes: 
\end_layout

\begin_layout Enumerate
Secuencia de tamaño fijo de bloques de memoria (los 
\emph on
buffers
\emph default
).
 La cantidad de 
\emph on
buffers
\emph default
 es limitada y se especifica al inicializar el sistema.
 Un buffer se corresponde con uno y solo un bloque de disco.
 El tamaño del buffer no puede ser menor al tamaño de un bloque de disco.
 
\end_layout

\begin_layout Enumerate
Secuencia de encabezados de buffers (
\emph on
buffer headers
\emph default
) que identifican a cada 
\emph on
buffer
\emph default
.
 Contienen:
\end_layout

\begin_deeper
\begin_layout Enumerate
Número lógico de dispositivo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
El número físico del disco lo calcula la controladora del disco.
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
Número de bloque en disco 
\end_layout

\begin_layout Enumerate
Banderas: 
\begin_inset Quotes eld
\end_inset

bloqueado/desbloqueado
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

datos válidos/inválidos
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

escribiendo/leyendo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

otro proceso está esperando por este buffer
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

escritura diferida
\begin_inset Quotes erd
\end_inset

 (el buffer contiene datos válidos que aún no fueron escritos en el disco)
 
\end_layout

\begin_layout Enumerate
Puntero al 
\emph on
buffer
\emph default
 en sí 
\end_layout

\begin_layout Enumerate
Puntero a los 
\emph on
buffers
\emph default
 anterior y siguiente en la cola de dispersión 
\end_layout

\begin_layout Enumerate
Puntero a los 
\emph on
buffers
\emph default
 libres anterior y siguiente en la lista de 
\emph on
buffers
\emph default
 libres 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center

\series bold
\begin_inset Graphics
	filename img/buffer cache.png
	scale 40

\end_inset


\series default
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\series bold
Buffer caché
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/buffer_free_list.jpg
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\series bold
Lista de buffers libres
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\begin_inset Caption

\begin_layout Plain Layout

\series bold
Buffer cache
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los buffer headers siempre están en alguna cola de dispersión, y pueden
 o no estar en la lista de 
\emph on
buffers
\emph default
 libres.
\end_layout

\begin_layout Standard
Los 
\series bold
buffers libres
\series default
 se almacenan mediante una lista circular doblemente enlazada de buffer
 headers.
 Esta lista preserva el orden de LRU.
 Cuando se necesita un buffer, se lo saca del principio de la lista (o del
 medio, si se necesitaba un buffer específico).
 Cuando se agrega un buffer libre, se lo agrega al final de la lista.
\end_layout

\begin_layout Standard
Los 
\series bold
buffers en uso
\series default
 se dividen en varias colas de dispersión (parámetro configurable), que
 pemiten que la búsqueda de un buffer en particular sea rápida.
 Cada cola es una lista doblemente enlazada de buffer headers.
 Cuando el kernel necesita un buffer, lo pone en una y solo una de las colas
 de dispersión, mediante la aplicación de una función de hash.
\end_layout

\begin_layout Standard
Cuando el kernel usa un buffer, lo marca como 
\begin_inset Quotes eld
\end_inset

bloqueado
\begin_inset Quotes erd
\end_inset

, y si no está en uso, lo desbloquea.
 Cuando se desbloquean, se los coloca en la lista de buffers libres (si
 tiene datos válidos, al final de la cola, y sino, al principio), pero no
 se los saca de las colas de dispersión.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

salida: ninguna
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	despertar todos los procesos que quieren un buffer libre
\end_layout

\begin_layout Plain Layout

	despertar todos los procesos que querian este buffer
\end_layout

\begin_layout Plain Layout

	bloquear interrupciones
\end_layout

\begin_layout Plain Layout

	si (buffer tiene datos validos y buffer no es viejo)
\end_layout

\begin_layout Plain Layout

		agregar buffer al final de la lista de buffers libres
\end_layout

\begin_layout Plain Layout

	si no:
\end_layout

\begin_layout Plain Layout

		agregar buffer al principio de la lista de buffers libres
\end_layout

\begin_layout Plain Layout

	permitir interrupciones
\end_layout

\begin_layout Plain Layout

	desbloquear(buffer)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo 
\family typewriter
brelse
\family default
 para liberar un buffer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

salida: buffer que contiene datos
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	obtener buffer del bloque (algoritmo getblk)
\end_layout

\begin_layout Plain Layout

	si (buffer tiene datos validos)
\end_layout

\begin_layout Plain Layout

		devolver buffer
\end_layout

\begin_layout Plain Layout

	iniciar lectura de disco a buffer
\end_layout

\begin_layout Plain Layout

	sleep (evento: lectura finalizada)
\end_layout

\begin_layout Plain Layout

	devolver buffer
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo 
\family typewriter
bread
\family default
 para leer un bloque
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

salida: buffer bloqueado que se puede usar para manejar un bloque de disco
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	buffer no encontrado = true
\end_layout

\begin_layout Plain Layout

	mientras (buffer no encontrado) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		cola de dispersion = cola((num Dispositivo * num Bloque) mod cant Colas)
\end_layout

\begin_layout Plain Layout

		si (bloque en cola de dispersion)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			bloquear interrupciones
\end_layout

\begin_layout Plain Layout

			si (buffer bloqueado) 
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				marcar el buffer con "hay un proceso esperando"
\end_layout

\begin_layout Plain Layout

				sleep (evento: buffer desbloqueado)
\end_layout

\begin_layout Plain Layout

				continuar
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			marcar el buffer como "bloqueado"
\end_layout

\begin_layout Plain Layout

			permitir interrupciones
\end_layout

\begin_layout Plain Layout

			remover el buffer de la lista de libres
\end_layout

\begin_layout Plain Layout

			devolver buffer
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		si no 
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			si (no hay buffers en la lista de libres)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				sleep (evento: se libera algun buffer)
\end_layout

\begin_layout Plain Layout

				continuar
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			remover primer buffer de la lista de libres
\end_layout

\begin_layout Plain Layout

			si (buffer marcado como "escritura diferida")
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				remover buffer de la lista de libres
\end_layout

\begin_layout Plain Layout

				marcar buffer como "escribiendo"		
\end_layout

\begin_layout Plain Layout

				escribir el buffer al disco asincronicamente 
\end_layout

\begin_layout Plain Layout

				// asinc = el kernel NO espera que la escritura termine
\end_layout

\begin_layout Plain Layout

				continuar
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			remover buffer de la vieja cola de dispersion
\end_layout

\begin_layout Plain Layout

			insertar buffer a la nueva cola de dispersion
\end_layout

\begin_layout Plain Layout

			devolver buffer
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo 
\family typewriter
getblk
\family default
 para obtener un bloque
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

salida: ninguna
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	iniciar escritura a disco
\end_layout

\begin_layout Plain Layout

	si (I/O sincronica)
\end_layout

\begin_layout Plain Layout

		sleep (evento: escritura completa)
\end_layout

\begin_layout Plain Layout

		liberar buffer (algoritmo brelse)
\end_layout

\begin_layout Plain Layout

	si (buffer marcado como "escritura diferida")
\end_layout

\begin_layout Plain Layout

		marcar el buffer para ponerlo al principio de la lista de libres
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo bwrite para escribir un bloque de disco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="7cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Ventajas
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Acceso uniforme al disco.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El sistema es vulnerable a caidas; lo que se escribió en el buffer pero
 no en el disco se pierde.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El coódigo es más prolijo.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La copia de datos muy grandes es más lenta, porque se realiza dos veces
 (del proceso al kernel y del kernel al disco).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No hay restricciones de alineación de bytes.
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduccion de accesos al disco.
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algoritmo 
\family typewriter
getblk
\family default
 previene corrupción de datos.
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Lectura adelantada de bloque
\end_layout

\begin_deeper
\begin_layout Standard
Tratar de colocar bloques en la caché antes de que se necesiten.
 Si se necesita el bloque 
\begin_inset Formula $k$
\end_inset

, se planifica una lectura 
\series bold
asincrónica
\series default
 al bloque 
\begin_inset Formula $k+1$
\end_inset

.
 Esta estrategia es más rápida para los archivos que se leen en forma secuencial.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Reducción del movimiento del brazo del disco
\end_layout

\begin_deeper
\begin_layout Standard
Al asignar bloques al disco, se intenta ponerlos de forma consecutiva (y
 en el mismo cilindro), utilizando el 
\emph on
bitmap 
\emph default
de bloques libres como referencia.
\end_layout

\begin_layout Standard
También la colocación de los nodos-i se puede optimizar, poniéndolos todos
 al principio del disco, o todos en el medio, o distribuidos en grupos de
 cilindros junto con la lista de bloques libres y los bloques.
\end_layout

\end_deeper
\begin_layout Section
Ejemplos de sistemas de archivos
\end_layout

\begin_layout Subsection
Linux: ext2
\end_layout

\begin_layout Standard

\emph on
Estructura del sistema de archivos:
\emph default
 
\end_layout

\begin_layout Itemize
Linux admite varias docenas de sistemas de archivos mediante la capa 
\series bold
\emph on
Virtual File System
\series default
\emph default
 (VFS).
 VFS oculta de los procesos y las aplicaciones de nivel superior las diferencias
 entre muchos tipos de sistemas de archivos que Linux acepta.
 VFS define un conjunto de abstracciones básicas del sistema de archivos
 y las operaciones que se permiten en estas abstracciones.
\end_layout

\begin_deeper
\begin_layout Standard
VFS acepta sistemas de archivos con cuatro estructuras principales:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Superbloque
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contiene información sobre el sistema de archivos.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Dentry
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Representa una entrada de directorio.
 Se crea mediante el sistema de archivos al instante.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Nodo-i
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cada nodo-i describe un archivo, directorio o dispositivo.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Archivo
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Representación en memoria de un archivo abierto.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Nombres de archivos de 255 caracteres.
 
\end_layout

\begin_layout Itemize

\series bold
Archivo
\series default
: consiste en una secuencia de 0 o más bytes.
 No se distingue entre archivos ASCII o binarios, o cualquier otro tipo.
 
\end_layout

\begin_layout Itemize
Es un sistema de archivos jerárquico.
 
\end_layout

\begin_layout Standard

\emph on
Sistema de archivos ext2:
\emph default
 
\end_layout

\begin_layout Itemize
Estructura:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/ext2.png
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Sistema de archivos ext2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Superblock
\emph default
: contiene la cantidad de nodos-i, la cantidad de bloques de disco, y el
 principio de la lista de bloques libres.
 
\end_layout

\begin_layout Itemize

\emph on
Descriptor de grupo
\emph default
: contiene la localización de los bitmaps, la cantidad de bloques y nodos-i
 libres, y la cantidad de directorios.
 
\end_layout

\begin_layout Itemize

\emph on
Bitmap de bloques
\emph default
, de 1 KB.
 
\end_layout

\begin_layout Itemize

\emph on
Bitmap de nodos-i
\emph default
, de 1 KB.
 
\end_layout

\begin_layout Itemize

\emph on
Nodos-i
\emph default
, de 128 bytes cada uno.
 
\end_layout

\begin_layout Itemize

\emph on
Bloques de datos
\emph default
.
 
\end_layout

\end_deeper
\begin_layout Itemize
Una entrada de directorio contiene:
\end_layout

\begin_deeper
\begin_layout Itemize
Número de nodo-i, 
\end_layout

\begin_layout Itemize
Tamaño de la entrada, 
\end_layout

\begin_layout Itemize
Tipo de entrada (archivo, directorio, dispositivo), 
\end_layout

\begin_layout Itemize
Longitud del nombre del archivo, 
\end_layout

\begin_layout Itemize
Nombre el archivo.
 
\end_layout

\end_deeper
\begin_layout Itemize
Cada proceso tiene su propia 
\emph on
file descriptor table
\emph default
 (tabla descriptora de procesos).
 El sistema tiene una única 
\emph on
open file descriptor table.

\emph default
 
\end_layout

\begin_layout Standard

\emph on
Seguridad
\emph default
: 
\end_layout

\begin_layout Itemize
Cada usuario tiene un
\series bold
 User ID
\series default
 (UID), un número entero desde 1 a 65.525.
 El usuario con UID 0 es el 
\series bold
root
\series default
 (supervisor).
 
\end_layout

\begin_layout Itemize
Los usuarios se pueden organizar en grupos.
 Cada grupo tiene su propio 
\series bold
Group ID
\series default
 (GID).
 
\end_layout

\begin_layout Itemize
Cada proceso lleva el UID y el GID de su dueño.
 
\end_layout

\begin_layout Itemize
Los permisos de los 
\series bold
archivos
\series default
 se heredan del proceso que los creó.
 Cada archivo tiene 
\series bold
9 bits de seguridad
\series default
: 3 bits 
\series bold
rwx 
\series default
(r=
\emph on
read
\emph default
, w=
\emph on
write
\emph default
, x=
\emph on
execute
\emph default
) para el dueño, 3 bits rwx para el grupo del dueño, y 3 bits rwx para el
 resto.
 
\end_layout

\begin_layout Itemize
Los directorios son archivos, y por lo tanto también tienen 9 bits de seguridad,
 pero el bit 
\series bold
x 
\series default
se refiere al permiso de búsqueda.
 
\end_layout

\begin_layout Subsection
Linux: ext3
\end_layout

\begin_layout Standard
Es el mismo que ext2 pero incorpora la funcionalidad de 
\emph on
journaling
\emph default
, por lo que ext3 es más lento que ext2.
\end_layout

\begin_layout Subsection
UNIX: BSD (Berkeley Software Distribution)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/unix file system.png
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
UNIX File System
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
Estructura del sistema de archivos:
\emph default
 
\end_layout

\begin_layout Itemize
Los 
\series bold
registros de directorio
\series default
 son de longitud variable.
 Cada uno contiene:
\end_layout

\begin_deeper
\begin_layout Itemize
Nombre del archivo o subdirectorio, 
\end_layout

\begin_layout Itemize
Número de nodo-i del archivo o subdirectorio.
 
\end_layout

\end_deeper
\begin_layout Itemize
El volumen se organiza en 
\series bold
bloques
\series default
 (en general de 4 KB cada uno), pero para minimizar la fragmentación interna,
 el sistema maneja 
\series bold
fragmentos de bloque
\series default
 que deben tener de tamaño submúltiplo del tamaño de bloque (por ejemplo,
 de 1 KB).
 Los fragmentos de bloque se utilizan para asignárselos a bloques finales
 de archivos.
 Entonces, un bloque puede tener fragmentos de distintos archivos, pero
 un archivo no puede tener sus fragmentos en distintos bloques.
 
\end_layout

\begin_layout Itemize
Un 
\series bold
volumen
\series default
 se compone de varias secciones:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Boot block
\series default
: contiene el módulo de arranque del sistema operativo de esa partición.
 
\end_layout

\begin_layout Enumerate

\series bold
Superblock
\series default
: contiene todos los parámetros clave acerca del sistema de archivos.
 Se encuentra replicado en distintas partes del sistema, para asegurar su
 integridad.
 Contiene:
\end_layout

\begin_deeper
\begin_layout Enumerate
Tamaño del sistema de archivos, 
\end_layout

\begin_layout Enumerate
Tamaño de los bloques, 
\end_layout

\begin_layout Enumerate
Bitmap para para control de fragmentos de bloque libres 
\end_layout

\begin_layout Enumerate
Cantidad de nodos-i libres, 
\end_layout

\begin_layout Enumerate
Lista de nodos-i libres, 
\end_layout

\begin_layout Enumerate
Puntero al primer nodo-i libre, 
\end_layout

\begin_layout Enumerate
Campos para bloquear los mapas de bloques y la lista de nodos-i libres,
 
\end_layout

\begin_layout Enumerate
Campo que indica que el superblock ha sido modificado.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Inode list
\series default
: lista de nodos-i del sistema de archivo.
 El tamaño de esta lista debe ser especificado por el administrador al configura
r el sistema.
 
\end_layout

\begin_layout Enumerate

\series bold
Data blocks
\series default
.
 Un block de datos puede pertenecer a uno y solo un archivo.
\end_layout

\begin_deeper
\begin_layout Standard
Los datos se dividen en áreas conformadas por cilindros adyacentes.
 Cada área tiene su superblock propio, para aumentar la seguridad.
 Cada grupo de cilindros tiene su propia lista de nodos-i.
 La política de asignación de espacio procura que los archivos queden localizado
s en una misma área.
 El sistema trata de ubicar los nodos-i de un directorio en una misma área.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Cada proceso tiene su propia 
\emph on
user file descriptor table
\emph default
.
 El sistema tiene una única 
\emph on
file table.
 
\emph default
Cuando un proceso abre o crea un archivo, el kernel devuelve un 
\emph on
file descriptor
\emph default
 que es un índice a la 
\emph on
user file descriptor table
\emph default
 de ese proceso.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
User file descriptor table
\emph default
: para cada archivo abierto por el proceso, contiene un puntero a la 
\emph on
file table
\emph default
 correspondiente a ese archivo.
 
\end_layout

\begin_layout Itemize

\emph on
File table
\emph default
: estructura global del kernel, que para cada archivo abierto, contiene
 el desplazamiento en bytes en el archivo donde comenzará la próxima lectura
 o escritura.
 
\end_layout

\begin_layout Itemize

\emph on
Inode table
\emph default
: 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/file descriptor table.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Relación entre las tablas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cuando se llama a una 
\emph on
system call 
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
System call
\emph default
: función que le pide un servicio al kernel del sistema operativo.
 
\end_layout

\end_inset

que involucra un 
\emph on
file descriptor
\emph default
, el
\emph on
 file descriptor
\emph default
 se utiliza como un índice a la 
\emph on
file descriptor table
\emph default
 para localizar el puntero a la 
\emph on
open file descriptor table
\emph default
 y a su vez al nodo-i correspondiente al archivo.
\end_layout

\end_deeper
\begin_layout Subsection
Microsoft: DOS (Disk Operating System)
\end_layout

\begin_layout Standard

\emph on
Estructura del sistema de archivos:
\emph default
 
\end_layout

\begin_layout Itemize
Los 
\series bold
directorios son archivos
\series default
 cuyos registros contienen datos sobre los archivos del directorio, y localizaci
ón del archivo en el disco:
\end_layout

\begin_deeper
\begin_layout Itemize
8 bytes para el nombre del archivo + estado del archivo (nunca usado, borrado)
 
\end_layout

\begin_layout Itemize
3 bytes para la extensión del nombre del archivo 
\end_layout

\begin_layout Itemize
1 byte para los atributos del archivo (normal, sólo lectura, oculto, de
 sistema, subdirectorio, modificado) 
\end_layout

\begin_layout Itemize
10 bytes reservados 
\end_layout

\begin_layout Itemize
2 bytes para la 
\series bold
hora
\series default
 en que el archivo fue creado o actualizado 
\end_layout

\begin_layout Itemize
2 bytes para la 
\series bold
fecha
\series default
 en que el archivo fue creado o actualizado 
\end_layout

\begin_layout Itemize
2 bytes para el bloque inicial del archivo en el disco 
\end_layout

\begin_layout Itemize
4 bytes para el tamaño del archivo en bytes 
\end_layout

\end_deeper
\begin_layout Standard

\emph on
Seguridad
\emph default
: no tiene mecanismos de seguridad más que la opción de ocultar archivos
 mediante el atributo correspondiente.
\end_layout

\begin_layout Standard

\emph on
Asignación
\emph default
 
\emph on
de espacio en dispositivos de almacenamiento
\emph default
: 
\end_layout

\begin_layout Enumerate

\series bold
Boot record
\series default
: contiene instrucciones para ayudar al sistema a cargar del disco a memoria
 programas para controlar la E/S de datos y para interpretar comandos.
 También contiene: nombre del fabricante, versión del sistema, cantidad
 de bytes por sector, cantidad de sectores por clúster, sectores reservados,
 sectores por pista, número de cabezas de lectoescritura.
 
\end_layout

\begin_layout Enumerate

\series bold
FAT
\series default
: contiene una entrada de 16 o 32 bits por cada clúster del disco.
 El registro de directorio de un archivo provee el clúster donde comienza
 el archivo, y la entrada de la FAT provee el número del siguiente clúster.
\end_layout

\begin_deeper
\begin_layout Enumerate
Valor 0: clúster libre, 
\end_layout

\begin_layout Enumerate
Valor 65.527: clúster dañado 
\end_layout

\begin_layout Enumerate
Valores 65.528 y 65.535: fin de archivo.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Sectores del directorio raíz
\series default
: el directorio raíz tiene capacidad limitada.
 
\end_layout

\begin_layout Enumerate

\series bold
Resto de los directorios
\series default
 
\end_layout

\begin_layout Subsection
Microsoft: NTFS (New Technology File System)
\end_layout

\begin_layout Standard

\emph on
Estructura del sistema de archivos:
\emph default
 
\end_layout

\begin_layout Itemize
Es un sistema de archivos jerárquico que se desarrolló específicamente para
 la versión Windows NT.
 
\end_layout

\begin_layout Itemize
Utiliza direcciones de disco de 64 bits, y por lo tanto acepta particiones
 de hasta 16 exabytes.
 
\end_layout

\begin_layout Itemize

\series bold
Archivo
\series default
: consiste en varios atributos, y cada uno se representa mediante un flujo
 de bytes.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Atributos residentes, se almacenan en la MTF
\end_layout

\begin_layout Itemize
Atributos no residentes
\end_layout

\end_deeper
\begin_layout Itemize
Hay soporte para 
\emph on
hard links
\emph default
, pero sólo se pueden aplicar a archivos del mismo volumen dado que al registro
 del archivo en la MFT se le agrega otro registro.
 Además, si se le cambia el tamaño o los atributos a un archivo, las entradas
 de los demás links pueden no ser actualizadas hasta que se abran.
 
\end_layout

\begin_layout Itemize
Hay soporte para 
\emph on
soft links
\emph default
.
 
\end_layout

\begin_layout Itemize
Cada volumen se organiza como una secuencia lineal de 
\series bold
clústeres
\series default
 (conjuntos de 
\series bold
sectores
\series default
) de tamaño fijo (por lo general, 4 KB).
 Los 
\series bold
fragmentos
\series default
 son conjuntos contiguos de clusters, y están especificados por:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Virtual Cluster Number
\emph default
 (VCN): número de cluster relativo respecto del archivo.
 
\end_layout

\begin_layout Itemize

\emph on
Logical Cluster Number
\emph default
 (LCN): número real de cluster lógico respecto del disco.
 
\end_layout

\begin_layout Itemize
Cantidad de clusteres contiguos a partir de LCN.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Master File Table (MFT)
\series default
: principal estructura de datos de cada volumen.
\end_layout

\begin_deeper
\begin_layout Itemize
Es un 
\series bold
archivo
\series default
 extensible hasta 
\begin_inset Formula $2^{48}$
\end_inset

 registros.
 Es una secuencia lineal de 
\series bold
registros
\series default
 de 1 KB cada uno.
 Cada registro consiste en un 
\series bold
encabezado de registro
\series default
 (número mágico para comprobar la validez del archivo, puntero al primer
 atributo, puntero al primer byte de espacio libre en el registro, número
 de registro base del archivo) más una secuencia de 
\series bold
pares
\series default
 
\begin_inset Formula $<$
\end_inset

encabezado de atributo (definición del atributo, longitud del valor), valor
 del atributo
\begin_inset Formula $>$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/mft_record.png
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Ejemplo de registro de la MFT.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Cada registro describe a un archivo o un directorio:
\end_layout

\begin_deeper
\begin_layout Itemize
Atributos del archivo.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/mft-atributos de un registro.png
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Atributos de un registro de la MFT.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Lista de direcciones de disco donde se encuentran sus bloques.
 
\end_layout

\end_deeper
\begin_layout Itemize
Los directorios chicos son registros con varias entradas de directorios,
 cada una de las cuales describe a un archivo o directorio.
 Los directorios grandes utilizan árboles B+ para listar archivos, facilitando
 la búsqueda alfabética y la inserción.
 
\end_layout

\begin_layout Itemize
Si el archivo ocupa muchos bloques en disco, el primer registro de la MFT
 (
\series bold
registro base
\series default
) de ese archivo apunta a los otros registros de la MFT del mismo archivo.
 
\end_layout

\begin_layout Itemize
Como es un archivo, se lo puede colocar en cualquier parte del disco.
 
\end_layout

\begin_layout Itemize
Un 
\series bold
bitmap
\series default
 lleva el registro de las entradas libres en la MFT.
 
\end_layout

\begin_layout Itemize
Los primeros 16 registros de la MFT se reservan para describir los archivos
 de metadatos de NTFS.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/mft.png
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
MFT de NTFS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\emph on
Seguridad:
\emph default
 
\end_layout

\begin_layout Itemize
NTFS proporciona compresión transparente de archivos.
 
\end_layout

\begin_layout Itemize
NTFS cuenta con una opción para cifrar directorios (y todos los archivos
 que hay en él).
 
\end_layout

\begin_layout Itemize
NTFS utiliza un diario de cambios (
\emph on
journal
\emph default
): es el archivo de metadatos 
\family typewriter
$LogFile
\family default
.
 Este archivo registra, cada 5 segundos, los cambios que se producen en
 todas las estructuras de disco, y si se completan con éxito, se elimina
 el registro correspondiente.
 Este archivo tiene dos tipos de registros:
\end_layout

\begin_deeper
\begin_layout Itemize
UNDO: para deshacer acciones que no se pudieron completar.
 
\end_layout

\begin_layout Itemize
REDO: para rehacer acciones que no se pudieron completar.
 
\end_layout

\end_deeper
\begin_layout Itemize
Cada usuario y grupo se identifica mediante un 
\series bold
SID
\series default
 (
\emph on
Security ID
\emph default
).
 Cada SID es único en el mundo.
 Cuando un usuario comienza un proceso, el proceso y sus hilos corren bajo
 el SID del usuario.
 
\end_layout

\begin_layout Itemize
Cada proceso tiene un 
\series bold
token de acceso
\series default
, que indica quién es el propietario del proceso y qué valores y poderes
 están asociados con él.
 
\end_layout

\begin_layout Itemize
Cada objeto tiene asociado en la MFT un 
\series bold
descriptor de seguridad
\series default
, que indica quién puede realizar operaciones sobre él.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="3cm">
<column alignment="left" valignment="top" width="13cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encabezado 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SID del propietario 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SID del grupo 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DACL (
\emph on
Discretionary Access List
\emph default
) 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Especifica quién puede usar el objeto.
 Contiene una o más ACL (
\emph on
Access Control Entries
\emph default
), y cada una de ellas tiene: un SID, un elemento binario (
\begin_inset Quotes eld
\end_inset

permitir/denegar
\begin_inset Quotes erd
\end_inset

), y un mapa de bits que indica qué tipo de operaciones tiene permitidas
 ese SID (
\emph on
execute, read, write, delete, write DAC, write owner
\emph default
).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SACL (
\emph on
System Access Control List
\emph default
) 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Especifica qué operaciones en el objeto se registran en el registro de eventos
 de seguridad del sistema.
 Contiene una o más ACL (
\emph on
Access Control Entries
\emph default
), y cada una de ellas tiene: un SID, un elemento (
\begin_inset Quotes eld
\end_inset

auditar
\begin_inset Quotes erd
\end_inset

), y un mapa de bits que indica qué tipo de operaciones se registrarán (
\emph on
execute, read, write, delete, write DAC, write owner
\emph default
).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Descriptor de seguridad.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
IBM OS/2: HPFS (High Performance File System)
\end_layout

\begin_layout Standard

\emph on
Estructura del distema de archivos
\emph default
: 
\end_layout

\begin_layout Itemize

\series bold
\emph on
File Node
\series default
\emph default
 (FNODE): registros de especificación de archivos y directorios.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/hpfs-fnode.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
FNODE.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Longitud del nombre del archivo 
\end_layout

\begin_layout Itemize
Primeros 15 caracteres del nombre del archivo 
\end_layout

\begin_layout Itemize
Puntero al directorio que contiene este archivo (LSN - Logical Sector Number)
\end_layout

\begin_layout Itemize
Información de control 
\end_layout

\begin_layout Itemize
Historia de accesos 
\end_layout

\begin_layout Itemize
Atributos extendidos 
\end_layout

\begin_layout Itemize
Listas de control de acceso 
\end_layout

\begin_layout Itemize
Punteros al archivo o puntero al bloque del directorio raíz: hasta ocho
\series bold
 punteros a fragmentos
\series default
 de archivo de hasta 16 MB cada uno.
 Cada puntero emplea 32 bits para la dirección inicial de cada fragmento
 y otros 32 bits para la cantidad de sectores contiguos de fragmentos.
 Si el archivo es muy grande y ocho punteros no son suficientes, se forma
 una estructura de árbol donde en lugar de guardar punteros se guardan punteros
 a 
\series bold
allocation nodes 
\series default
(alnodes), con capacidad para 40 punteros a fragmentos cada uno.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Directorios
\series default
 formados por uno o más bloques de directorio de 2 kb.
 Cada 
\series bold
entrada de directorio 
\series default
contiene: longitud de entrada, fechas, longitud del nombre del archivo o
 subdirectorio, nombre del archivo o subdirectorio, puntero al FNODE (contiene
 información del archivo u otro puntero), puntero al bloque de directorio
 sucesor.
 
\end_layout

\begin_layout Itemize
Si un directorio es muy grande para ser descrito en un bloque, se le asignan
 más bloques y se organiza como un 
\series bold
árbol B
\series default
.
 
\end_layout

\begin_layout Itemize
Directorios ordenados alfabéticamente.
 
\end_layout

\begin_layout Itemize
Estructura del volumen:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/hpfs-volumen.png
	scale 45

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
HPFS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Boot block
\series default
 (sectores 0 a 15), volume ID, bootstrap.
\end_layout

\begin_layout Itemize

\series bold
Super block
\series default
 (puntero al FNODE del directorio raíz) 
\end_layout

\begin_layout Itemize

\series bold
Spare block
\series default
 (tabla de hotfixes + Bloque de Directorio Vacío) 
\end_layout

\begin_layout Itemize

\series bold
Bandas
\series default
.
 Las bandas miden 8 MB.
 Entre cada banda hay un 
\emph on
bitmap
\emph default
 de 8 KB de sectores libre.
 Una de las bandas es la de bloques de directorio.
 
\end_layout

\end_deeper
\begin_layout Standard

\emph on
Seguridad
\emph default
: 
\end_layout

\begin_layout Itemize
Los FNODES contienen listas de control de acceso.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Organización de archivos
\end_layout

\begin_layout Section
Archivos planos - 
\emph on
streams
\end_layout

\begin_layout Standard
En C/C++ hay dos formas posibles de manejar un archivo: utilizando rutinas
 de biblioteca, incluídas en 
\family typewriter
stdio.h,
\family default
 o utilizando 
\emph on
system calls.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Utilizando rutinas
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Utilizando system calls
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La entrada/salida se realiza en 
\emph on
registros
\emph default
.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La entrada/salida se realiza en 
\emph on
bytes
\emph default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Primitivas para el manejo de archivos:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2.2cm">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Utilizando rutinas
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Utilizando system calls
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apertura 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

FILE* fopen (char* nombreArchivo, char* modoApertura); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int open (char* nombreArchivo, int flag_apertura [,int permisos])
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lectura 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

unsigned int fread (void* bufferDestino, unsigned tamReg, unsigned cantidadRegs,
 FILE* punteroAlArchivo); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int read (int fileDescriptor, void* bufferDestino, unsigned cantidadBytes);
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Escritura 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

unsigned int fwrite (void* bufferFuente, unsigned tamReg, unsigned cantidadRegs,
 FILE* punteroAlArchivo); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int write (int fileDescriptor, void* bufferFuente, unsigned cantidadBytes);
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Posicionamiento 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int fseek (FILE* punteroAlArchivo, long offset, int origen); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int lseek (int fileDescriptor, long offset, int origen); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cierre 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int fclose (FILE* punteroAlArchivo); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\family default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

int close (int fileDescriptor); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Medios de almacenamiento físicos
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="2cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Nombre
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Descripción
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Costo
\emph default
 $ 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Capacidad
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
¿Es volátil?
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Velocidad de transferencia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Caché
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manejado por hardware.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy caro 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy poca 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy alta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memoria principal
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desde varios megabytes a varios gigabytes.
 Permite acceso aleatorio.
 Compuestos por celdas de un byte cada una.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Caro 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poca 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy alta (20 segundos)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memoria flash
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Para sobreescribir memoria, hay que borrar todo.
 Soporta un numero limitado de ciclos de borrado.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Caro 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Poca 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Discos magnéticos
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cintas magnéticas, discos duros, diskettes.
 Cada 
\series bold
plato
\series default
 del disco está dividido en 
\series bold
pistas
\series default
, que son conjuntos de 
\series bold
sectores
\series default
.
 El conjunto de todas las pistas 
\begin_inset Formula $i$
\end_inset

 de todos los platos conforman el 
\series bold
cilindro
\series default
 
\begin_inset Formula $i$
\end_inset

.
 Un 
\series bold
bloque
\series default
 es un conjunto de sectores.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Barato 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grande 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Baja (58 días)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Discos ópticos
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CD (700 MB), DVD (4,7 GB), BluRay (25 GB) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Barato 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grande 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Baja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cintas
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se usa para crear copias de respaldo.
 Solo permite acceso secuencial.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy barato 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Grandísima 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy baja
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Tipos de almacenamiento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\begin_inset Graphics
	filename img/disk.png
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Disco magnético.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Organización de archivos
\end_layout

\begin_layout Standard
Historia: 
\end_layout

\begin_layout Enumerate
Archivos secuenciales, uso de cintas magnéticas
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Mucho tiempo para hacer un seek!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Índices que tenían una clave y el offset al archivo secuencial
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
El índice podía ser muy grande!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Árboles n-arios para almacenar el índice
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Podían desbalancearse fácilmente 
\begin_inset Formula $\implies$
\end_inset

 Mucho tiempo para hacer un seek!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Árboles n-arios balanceados (AVL)
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Aún requerían muchos accesos a disco!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Árboles B
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Los archivos no se pueden acceder de forma secuencial!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Árbol B+
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Aún requerían varios accesos a disco!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Hashing (tablas de dispersión)
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
El archivo no debe crecer de tamaño demasiado!
\emph default
 
\end_layout

\end_deeper
\begin_layout Enumerate
Hashing extensible 
\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: cómo organizar datos en archivos para optimizar la eficiencia en almacenamient
o en disco, recuperación de disco y resguardo de los datos.
\end_layout

\begin_layout Standard
Lo ideal es 1 acceso a disco, o la cantidad mínima que se pueda, para obtener
 toda la información que necesitamos en una sola lectura.
 
\end_layout

\begin_layout Itemize
¿Dónde almacenar nuevos registros? 
\end_layout

\begin_layout Itemize
¿Cómo encontrar registros para borrarlos, modificarlos, o recuperarlos?
 
\end_layout

\begin_layout Standard

\series bold
Archivo
\series default
: colección de 
\series bold
registros
\series default
 formados por 
\series bold
campos
\series default
, que se mapean a 
\series bold
bloques
\series default
 del disco.
 El tamaño de los bloques es fijo y es determinado por el sistema operativo,
 pero el tamaño de los registros puede variar.
\end_layout

\begin_layout Standard

\series bold
Fragmentación interna
\series default
: espacio perdido dentro de un registro, generalmente al final.
\end_layout

\begin_layout Standard

\series bold
Fragmentación externa
\series default
: espacio perdido entre registros.
\end_layout

\begin_layout Section
Estructura de campos
\end_layout

\begin_layout Standard

\emph on
¿Cómo representar campos de manera que no pierdan su identidad?
\emph default
 
\end_layout

\begin_layout Itemize
Campos de longitud limitada
\end_layout

\begin_deeper
\begin_layout Itemize
Pierdo espacio 
\end_layout

\begin_layout Itemize
Puedo no estar contemplando valores muy grandes 
\end_layout

\end_deeper
\begin_layout Itemize
Campos comienzan con su longitud en bytes
\end_layout

\begin_deeper
\begin_layout Itemize
El tamaño del 
\emph on
campo que representa la longitud del campo
\emph default
 debe elegirse con cuidado! Con 1 campo de 1 byte podemos decir, como máximo,
 
\begin_inset Quotes eld
\end_inset

registro de 256 bytes a continuación
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Itemize
Campos separados por un delimitador
\end_layout

\begin_deeper
\begin_layout Itemize
El delimitador tiene que ser elegido con cuidado! 
\end_layout

\end_deeper
\begin_layout Itemize
Campos identificados por el par 
\begin_inset Quotes eld
\end_inset

clave, valor
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Section
Estructura de registros
\end_layout

\begin_layout Standard

\series bold
Registros de longitud fija:
\series default
 producen fragmentación interna.
 
\end_layout

\begin_layout Enumerate
¿
\emph on
Cómo borramos un registro y luego reclamamos el espacio? 
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Estático
\series default
\emph on
: 
\emph default
marcar el registro como borrado.
 Luego de que se borraron suficientes registros, se realiza una reconstrucción
 del archivo, eliminando los registros vacíos.
\end_layout

\begin_deeper
\begin_layout Enumerate
Ventaja: borrar un registro es rápido.
 
\end_layout

\begin_layout Enumerate
Desventaja: reorganizar el archivo es lento.
 
\end_layout

\begin_layout Standard
Para insertar un registro nuevo, se busca secuencialmente hasta encontrar
 un registro borrado.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Dinámico
\series default
: usar una lista enlazada de registros libres.
 Le agregamos un 
\series bold
file header 
\series default
al archivo que apunte al primer registro libre, el cual apunta al segundo
 registro libre, y así sucesivamente.
\end_layout

\begin_deeper
\begin_layout Standard
Para borrar un registro: copiamos lo que dice el 
\emph on
file header
\emph default
 al registro.
 Y en el 
\emph on
file header
\emph default
 ponemos el número de registro que queremos borrar.
\end_layout

\begin_layout Standard
Para insertar un registro: mantenemos una copia del número de registro apuntado
 por el registro apuntado por el 
\emph on
file header.
 
\emph default
En el registro apuntado por el 
\emph on
file header
\emph default
 copiamos el registro.
 En el 
\emph on
file header
\emph default
 ponemos la copia de antes.
\end_layout

\begin_layout Standard
Estructura de archivo necesaria: 
\end_layout

\begin_layout Enumerate

\emph on
File header
\emph default
: número del primer registro libre, -1 si no hay libres.
 
\end_layout

\begin_layout Enumerate
Para cada registro:
\end_layout

\begin_deeper
\begin_layout Enumerate
Bit bandera (
\begin_inset Quotes eld
\end_inset

libre/ocupado
\begin_inset Quotes erd
\end_inset

) 
\end_layout

\begin_layout Enumerate
Datos.
 Si está 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

: puntero a próximo registro libre.
 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
¿Como nos aseguramos que un registro requiera solo un acceso a disco? 
\end_layout

\begin_deeper
\begin_layout Standard
Hay que asegurarse de que el tamaño del bloque sea un múltiplo del tamaño
 del registro.
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Registros de longitud variable:
\series default
 producen fragmentación externa.
 
\end_layout

\begin_layout Itemize

\emph on
¿Cómo los implementamos?
\end_layout

\begin_deeper
\begin_layout Enumerate
Usar 
\series bold
delimitadores
\series default
 que marquen el fin de un registro.
 
\end_layout

\begin_layout Enumerate
Agregar el 
\series bold
tamaño del registro
\series default
 al comienzo del mismo.
 
\end_layout

\begin_layout Enumerate
Usando 
\series bold
registros de longitud fija
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Si hay un 
\series bold
tamaño máximo
\series default
 de registro que nunca se sobrepasa, usamos registros de ese tamaño para
 albergar registros de longitud variable.
\end_layout

\begin_deeper
\begin_layout Standard
Problema: desperdicia mucho espacio.
\end_layout

\end_deeper
\begin_layout Itemize
Un registro de longitud variable (RV) es representado por una lista enlazada
 de registros de longitud fija (RF).
\end_layout

\begin_deeper
\begin_layout Standard
Problema: El primer RF del RV no desperdicia espacio, pero el resto sí (porque
 solo almacenan la información que no cabe en el primer RF).
\end_layout

\begin_layout Standard
Solución: usar 
\series bold
bloques ancla
\series default
 que contienen el primer RF, y usar 
\series bold
bloques de overflow
\series default
 que contienen la continuación de la lista.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Si los registros tienen una 
\series bold
clave
\series default
, usando un 
\series bold
índice
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
El índice posee la clave primaria de cada registro, ordenados alfabéticamente
 para poder hacer búsquedas binarias.
 Para cada clave se guarda el offset al archivo de datos.
 
\end_layout

\begin_layout Itemize
El archivo de datos posee un encabezado que guarda el offset al primer registro
 libre.
 Luego, para cada registro de longitud variable, se guarda:
\end_layout

\begin_deeper
\begin_layout Itemize
La longitud de ese registro (para saber cuánto ocupa) 
\end_layout

\begin_layout Itemize
Un bit bandera 
\begin_inset Quotes eld
\end_inset

libre/ocupado
\begin_inset Quotes erd
\end_inset

 (para poder borrar un registro) 
\end_layout

\begin_layout Itemize
La cantidad de bytes libres del registro (en una modificación de un registro,
 puede que el nuevo registro sea más pequeño que el viejo; también se utiliza
 para encadenar registros libres) 
\end_layout

\begin_layout Itemize
Datos 
\end_layout

\begin_layout Standard

\emph on
Algoritmo de borrado
\emph default
: buscar el registro en el índice, buscar el registro en el archivo de datos,
 marcarlo como 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

.
 Si el registro anterior o el siguiente están libres también, fundirlos
 en un solo registro libre.
 Borrar la clave del índice.
\end_layout

\begin_layout Standard

\emph on
Algoritmo de agregado
\emph default
: Si hay registros libres, seleccionar uno
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Estrategias de selección: 
\end_layout

\begin_layout Itemize
First-fit: devolver el primer registro vacío libre tal que 
\begin_inset Formula $tam(reg\, vac\acute{\imath}o)\geq tam(reg)$
\end_inset

 
\end_layout

\begin_layout Itemize
Best-fit: ordenar la lista de registros vacíos en orden 
\series bold
ascendente
\series default
 por tamaño, devolver el primer registro vacío libre tal que 
\begin_inset Formula $tam(reg\, vac\acute{\imath}o)\geq tam(reg)$
\end_inset

 
\end_layout

\begin_layout Itemize
Worst-fit: ordenar la lista de registros vacíos en orden 
\series bold
descendente
\series default
 por tamaño, devolver el primero.
\end_layout

\end_inset

 y guardar el registro ahí, y actualizar la lista de registros libres.
 Si no hay registros libres, agregarlo al final del archivo.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Section
Modos de acceso a archivos
\end_layout

\begin_layout Itemize

\series bold
Secuencial
\series default
: los registros se acceden en orden, empezando por el principio, sin poder
 saltearse ninguno ni volver atrás.
\end_layout

\begin_deeper
\begin_layout Standard
Formas de organización recomendadas si se prefiere este modo de acceso:
 
\end_layout

\begin_layout Itemize
Organización secuencial (tira de bytes) 
\end_layout

\begin_layout Itemize
Organización balanceada secuencial (árbol B+ o B#) 
\end_layout

\begin_layout Itemize
Organización secuencial indexada (archivo secuencial + índice) 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Relativo
\series default
: los registros se acceden con posicionamiento.
\end_layout

\begin_deeper
\begin_layout Standard
Formas de organización recomendadas si se prefiere este modo de acceso:
 
\end_layout

\begin_layout Itemize
Organización balanceada no secuencial (árbol B o B*) 
\end_layout

\begin_layout Itemize
Organización directa (mediante hashing) 
\end_layout

\begin_layout Itemize
Organización indexada 
\end_layout

\end_deeper
\begin_layout Subsection
Modos de búsqueda
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $n$
\end_inset

 la cantidad de registros de un archivo.
 
\end_layout

\begin_layout Itemize
Búsqueda 
\series bold
secuencial
\series default
: 
\begin_inset Formula $O(n)$
\end_inset

 
\end_layout

\begin_layout Itemize
Búsqueda 
\series bold
secuencial por bloques
\series default
: 
\begin_inset Formula $O(n)$
\end_inset

 
\end_layout

\begin_layout Itemize
Búsqueda 
\series bold
directa
\series default
: 
\begin_inset Formula $O(1)$
\end_inset

 
\end_layout

\begin_layout Itemize
Búsqueda 
\series bold
binaria
\series default
: 
\begin_inset Formula $O\left(\log_{2}n\right)$
\end_inset

.
 El archivo debe estar ordenado.
 
\end_layout

\begin_layout Section
Archivos secuenciales
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

int S_OPEN (const char* nombreArchivo, int modoApertura); 
\end_layout

\begin_layout Plain Layout

int S_CLOSE (int fileHandler);
\end_layout

\begin_layout Plain Layout

int S_READ (int fileHandler, void* regDestino); 
\end_layout

\begin_layout Plain Layout

int S_WRITE (int fileHandler, const void* regFuente, unsigned long cantBytes);
 
\end_layout

\begin_layout Plain Layout

int S_DESTROY (const char* nombreArchivo); 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Primitivas de la organización secuencial
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Archivos relativos
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

int R_OPEN (const char* nombreArchivo, int modo);
\end_layout

\begin_layout Plain Layout

int R_CLOSE (int fileHandler); 
\end_layout

\begin_layout Plain Layout

int R_SEEK (int fileHandler, int numReg); 
\end_layout

\begin_layout Plain Layout

int R_READ (int fileHandler, int numReg, void* regDestino);
\end_layout

\begin_layout Plain Layout

int R_READNEXT (int fileHandler, void* regDestino); 
\end_layout

\begin_layout Plain Layout

int R_WRITE (int fileHandler, int numReg, const void* regFuente);
\end_layout

\begin_layout Plain Layout

int R_UPDATE (int fileHandler, int numReg, const void* regFuente); 
\end_layout

\begin_layout Plain Layout

int R_DELETE (int fileHandler, int numReg);
\end_layout

\begin_layout Plain Layout

int R_DESTROY (const char* nombreArchivo);
\end_layout

\begin_layout Plain Layout

int R_GETMAXREGS (int fileHandler); 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Primitivas de la organización relativa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Archivos directos y hashing
\end_layout

\begin_layout Standard

\series bold
Archivo directo estático
\series default
: 
\end_layout

\begin_layout Itemize
El archivo tiene longitud fija y 
\series bold
no extensible
\series default
.
 
\end_layout

\begin_layout Itemize
Los
\series bold
 registros tienen longitud fija
\series default
 y tienen una clave primaria.
 
\end_layout

\begin_layout Itemize
Cada registro del archivo posee un atributo extra que indica si el mismo
 está 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ocupado
\begin_inset Quotes erd
\end_inset

, o fue 
\begin_inset Quotes eld
\end_inset

borrado
\begin_inset Quotes erd
\end_inset

 del archivo.
 
\end_layout

\begin_layout Itemize
Para realizar altas, bajas y modificaciones de registros en el archivo,
 se debe calcular su posición en el mismo con una 
\series bold
función de hashing
\series default
.
 Si dos registros hashean a la misma posición, la colisión debe resolverse.
 
\end_layout

\begin_layout Standard
Factor de carga del archivo: 
\series bold

\begin_inset Formula $\frac{\#\, registros\, ocupados}{\#\, registros\, disponibles}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

int D_OPEN (const char* nombreArchivo, int modoApertura);
\end_layout

\begin_layout Plain Layout

int D_CLOSE (int handler); 
\end_layout

\begin_layout Plain Layout

int D_READ (int fileHandler, void* regDestino); 
\end_layout

\begin_layout Plain Layout

int D_WRITE (int fileHandler, const void* regFuente);
\end_layout

\begin_layout Plain Layout

int D_UPDATE (int fileHandler, const void* regFuente); 
\end_layout

\begin_layout Plain Layout

int D_DELETE (int fileHandler, const void* regFuente); 
\end_layout

\begin_layout Plain Layout

int D_DESTROY (const char* nombreArchivo); 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Primitivas de la organización directa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Función de hashing
\series default
: función 
\begin_inset Formula $f$
\end_inset

 tal que 
\begin_inset Formula $f(k)=offset$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Espacio de claves 
\end_layout

\begin_layout Itemize
Espacio de direcciones 
\end_layout

\begin_layout Standard

\series bold
Claves sinónimas 
\series default
producen
\series bold
 colisión
\series default
: evento en el cual, para dos claves 
\begin_inset Formula $k_{1}$
\end_inset

 y 
\begin_inset Formula $k_{2}$
\end_inset

 (
\begin_inset Formula $k_{1}\neq k_{2}$
\end_inset

), se da que 
\begin_inset Formula $f(k_{1})=f(k_{2})$
\end_inset

.
\end_layout

\begin_layout Subsection
Funciones de hashing perfectas
\end_layout

\begin_layout Standard
No produce colisiones.
 Se pueden construir si conocemos de antemano las claves a hashear.
\end_layout

\begin_layout Subsection
Funciones de hashing no perfectas
\end_layout

\begin_layout Standard
Pueden producir colisiones.
 
\end_layout

\begin_layout Itemize

\series bold
Función módulo
\series default
: 
\begin_inset Formula $f(k)=k\, mod\, N$
\end_inset

.
 El valor de 
\begin_inset Formula $N$
\end_inset

 debería ser primo para que la función disperse uniformemente.
\end_layout

\begin_deeper
\begin_layout Itemize
Espacio de direcciones: 
\begin_inset Formula $[0..N-1]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Función multiplicación
\series default
: 
\begin_inset Formula $f(k)=\left\lfloor N\cdot\left[k\left(x-1\right)\right]\right\rfloor $
\end_inset

.
 El valor de 
\begin_inset Formula $x$
\end_inset

 debería ser irracional.
\end_layout

\begin_deeper
\begin_layout Itemize
Espacio de direcciones: 
\begin_inset Formula $[0..N-1]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Función 
\emph on
fold&add
\series default
\emph default
: dividir la clave en partes de 2 o 4 bytes, aplicar la función de hashing
 a cada parte, y luego aplicar una operación que concatene los resultados
 (suma, XOR, etc.) 
\end_layout

\begin_layout Subsection
Aplicaciones
\end_layout

\begin_layout Itemize

\series bold
Rolling hashing 
\series default
es una función de hash donde la entrada se hashea en una ventana que se
 mueve a lo largo de la entrada.
\end_layout

\begin_deeper
\begin_layout Itemize
Algoritmo de Rabin-Karp: es un método que usa una función de hashing para
 buscar un patrón de string en un texto.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
H=c_{1}a^{k-1}+c_{2}a^{k-2}+\ldots+c_{k}a^{0}
\]

\end_inset

, donde 
\begin_inset Formula $a$
\end_inset

 es constante y 
\begin_inset Formula $c_{1}\ldots c_{k}$
\end_inset

 son los caracteres de la entrada.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Filtros de Bloom
\series default
: para verificar la pertenencia de un elemento en un conjunto.
 
\end_layout

\begin_layout Subsection
Funciones de hashing unidireccionales
\end_layout

\begin_layout Standard
Una 
\series bold
función de hashing unidireccional 
\series default
es de la forma 
\begin_inset Formula $H(M)=k$
\end_inset

.
 Tienen ciertos requisitos: 
\end_layout

\begin_layout Itemize
Toma un valor de longitud variable 
\begin_inset Formula $M$
\end_inset

 y devuelve un valor de longitud fija 
\begin_inset Formula $k$
\end_inset

 (generalmente la longitud es de 128 bits).
 
\end_layout

\begin_layout Itemize
Dado 
\begin_inset Formula $M$
\end_inset

 debe ser sencillo calcular 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Dado 
\begin_inset Formula $k$
\end_inset

 debe ser muy difícil encontrar un 
\begin_inset Formula $M$
\end_inset

 tal que 
\begin_inset Formula $H(M)=k$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Dado 
\begin_inset Formula $M$
\end_inset

 debe ser muy difícil encontrar un 
\begin_inset Formula $M'$
\end_inset

 tal que 
\begin_inset Formula $H(M)=H(M')$
\end_inset

 
\end_layout

\begin_layout Standard
Aplicaciones: 
\end_layout

\begin_layout Itemize
Autenticación de documentos 
\end_layout

\begin_layout Itemize
Firmas digiales 
\end_layout

\begin_layout Itemize
Códigos de verificación 
\end_layout

\begin_layout Standard
Algunas funciones de hashing unidireccionales: 
\end_layout

\begin_layout Enumerate

\series bold
MD5
\series default
: devuelve un valor de 128 bits.
 
\end_layout

\begin_layout Enumerate

\series bold
SHA
\series default
: devuelve un valor de 160 bits.
 
\end_layout

\begin_layout Subsection
Resolución de colisiones en archivos directos estáticos
\end_layout

\begin_layout Enumerate

\series bold
Búsqueda de posición libre
\end_layout

\begin_deeper
\begin_layout Standard
Sean las funciones de hashing 
\begin_inset Formula $f(k)=offset$
\end_inset

 y 
\begin_inset Formula $g(k)=offset_{g}$
\end_inset

 y el número de iteración 
\begin_inset Formula $i$
\end_inset

.
 
\begin_inset Formula $P_{i}$
\end_inset

 es la posición en el archivo relativo donde se debe comprobar la inserción
 o búsqueda.
 
\end_layout

\begin_layout Enumerate
Linealmente y cíclicamente: 
\begin_inset Formula 
\[
P_{i}=f(k)+i
\]

\end_inset

Se inserta en el primer lugar disponible (registro 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

borrado
\begin_inset Quotes erd
\end_inset

) a partir de 
\begin_inset Formula $offset$
\end_inset

.
 Si se llega al final del archivo, se vuelve al principio del mismo y se
 busca hasta llegar a 
\begin_inset Formula $offset$
\end_inset

.
 Si llegó a 
\begin_inset Formula $offset$
\end_inset

 es porque no hay lugar disponible.
\end_layout

\begin_deeper
\begin_layout Standard
Las búsquedas de un registro terminan cuando: 
\end_layout

\begin_layout Itemize
Se encuentra el registro, o 
\end_layout

\begin_layout Itemize
Se encuentra un registro 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

, o 
\end_layout

\begin_layout Itemize
Se vuelve a la posición inicial 
\begin_inset Formula $offset$
\end_inset

 (luego de hacer un ciclo).
 
\end_layout

\begin_layout Standard
Para borrar: buscar y marcar como 
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Desventaja: aglomeramiento de sinónimos en porciones del archivo.
\end_layout

\end_deeper
\begin_layout Enumerate
Cuadrático y cíclico:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
P_{i}=f(k)+i^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Ídem anterior.
\end_layout

\end_deeper
\begin_layout Enumerate
Doble hashing: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P_{i}=f(k)+i\cdot g(k)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Uso de área de overflow
\end_layout

\begin_deeper
\begin_layout Standard
Es el lugar donde se guardan los registros sinónimos.
 
\end_layout

\begin_layout Enumerate
En el mismo archivo de datos.
\end_layout

\begin_deeper
\begin_layout Enumerate
Área de overflow distribuida.
 Los registros de overflow se intercalan con los archivos de datos (
\begin_inset Formula $b$
\end_inset

 registros de overflow por cada 
\begin_inset Formula $a$
\end_inset

 registros de datos).
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $Posicion(k)=k+b(x\, div\, a)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $PosicionOverflow(k)=b(x\, div\, a)+a\left[(x\, div\, a)+1\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Área de overflow al final.
 
\end_layout

\end_deeper
\begin_layout Enumerate
En otro archivo.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Encadenamiento de claves sinónimos (direccionamiento cerrado)
\end_layout

\begin_deeper
\begin_layout Enumerate
En el mismo archivo: cada registro posee, además del flag antes mencionado
 (
\begin_inset Quotes eld
\end_inset

libre
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ocupad
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

borrado
\begin_inset Quotes erd
\end_inset

), un puntero a otro registro sinónimo.
 Si el registro no tiene sinónimos, este puntero es -1.
\end_layout

\begin_deeper
\begin_layout Standard
Método de doble pasada para cargar el archivo: 
\end_layout

\begin_layout Enumerate
Guardar las claves que no producen colisiones.
 
\end_layout

\begin_layout Enumerate
Guardar las claves que producen colisiones, encadenando los sinónimos.
 
\end_layout

\end_deeper
\begin_layout Enumerate
En otro archivo: cada registro posee, además del flag antes mencionado,
 un puntero a un registro del archivo de overflow.
 Este a su vez posee encadenamiento de sinónimos (fin marcado con un puntero
 -1).
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Uso de buckets
\series default
: un bucket almacena una cantidad fija de registros.
 Cuando hay overflow en el bucket, se debe utilizar otra técnica de resolución
 de colisiones.
 
\end_layout

\begin_layout Enumerate

\series bold
Uso de varias funciones de hashing
\series default
 
\end_layout

\begin_layout Subsection
Hashing extensible
\end_layout

\begin_layout Standard
Permite que el archivo crezca sin cambiar la función de hashing.
\end_layout

\begin_layout Standard
Se necesitan 4 estructuras: 
\end_layout

\begin_layout Enumerate
Archivo de tabla de dispersión, que guarda su 
\series bold
tamaño de tabla
\series default
 (tt)\SpecialChar \@.
 La tabla posee punteros a bloques.
 
\end_layout

\begin_layout Enumerate
Archivo con bloques.
 Cada bloque soporta una 
\series bold
cantidad fija de registros de longitud fija
\series default
.
 Cada bloque tiene su 
\series bold
tamaño de dispersión
\series default
 (td).
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
bloque.td=\frac{tabla.tt}{\#refs\, bloque\, en\, tabla}=distancia\, en\, tabla\, a\, otra\, ref
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Archivo con lista de bloques libres.
 
\end_layout

\begin_layout Enumerate
Función de hashing 
\begin_inset Formula $f$
\end_inset

 tal que 
\begin_inset Formula $f(clave)=$
\end_inset

posición en la tabla que nos dará el puntero al bloque.
 
\end_layout

\begin_layout Standard
Métodos: 
\end_layout

\begin_layout Itemize

\series bold
Mediante bit sufijos
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Las claves se representan en base 10.
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(clave)=clave\, mod\, tabla.tt$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	int posTabla = fhash(registro.clave)
\end_layout

\begin_layout Plain Layout

	int numeroBloque = tabla[posTabla]
\end_layout

\begin_layout Plain Layout

	Bloque bloque = bloques[numeroBloque]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.contiene(registro.clave))
\end_layout

\begin_layout Plain Layout

		return RES_REGISTRO_DUPLICADO
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.cantRegsLibres > tabla.cantRegsPorBloque)
\end_layout

\begin_layout Plain Layout

		bloque.insertar(registro)
\end_layout

\begin_layout Plain Layout

		return RES_OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// La clave no esta en el bloque y no se puede insertar en el
\end_layout

\begin_layout Plain Layout

	// El bloque aparece referenciado en la tabla solo 1 vez
\end_layout

\begin_layout Plain Layout

	if (bloque.td == tabla.tt)
\end_layout

\begin_layout Plain Layout

		tabla.duplicar()
\end_layout

\begin_layout Plain Layout

		tabla.tt *= 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Bloque nuevoBloque // Uno nuevo o el primero de bloquesLibres
\end_layout

\begin_layout Plain Layout

		bloques.agregar(nuevoBloque) // Si cree uno nuevo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		bloque.td *= 2
\end_layout

\begin_layout Plain Layout

		nuevoBloque.td = bloque.td
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Actualizo la referencia en la tabla
\end_layout

\begin_layout Plain Layout

		tabla[posTabla] = numNuevoBloque
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	// La clave no esta en el bloque y no se puede insertar en el
\end_layout

\begin_layout Plain Layout

	// El bloque aparece referenciado en la tabla mas de 1 vez
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		Bloque nuevoBloque // Uno nuevo o el primero de bloquesLibres
\end_layout

\begin_layout Plain Layout

		bloques.agregar(nuevoBloque) // Si cree uno nuevo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		bloque.td *= 2
\end_layout

\begin_layout Plain Layout

		nuevoBloque.td = bloque.td
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Actualizo las referencias en la tabla
\end_layout

\begin_layout Plain Layout

		int punteroInicial = numBloque
\end_layout

\begin_layout Plain Layout

		while (tabla[punteroInicial] == numBloque)
\end_layout

\begin_layout Plain Layout

			tabla[punteroInicial] = numNuevoBloque
\end_layout

\begin_layout Plain Layout

			punteroInicial = (punteroInicial + bloque.td) mod (tabla.tt)
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

	bloque.redispersar() // Aplicar otra vez la funcion de hashing a sus elementos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	insertar(registro, tabla, bloques)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Alta mediante bits sufijos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	int posTabla = funcionMod(registro.clave)
\end_layout

\begin_layout Plain Layout

	int numeroBloque = tabla[posTabla]
\end_layout

\begin_layout Plain Layout

	Bloque bloque = bloques[numeroBloque]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (! bloque.contiene(registro.clave))
\end_layout

\begin_layout Plain Layout

		return RES_REGISTRO_NO_EXISTE
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.cantRegsLibres > 1)
\end_layout

\begin_layout Plain Layout

		bloque.eliminar(registro)
\end_layout

\begin_layout Plain Layout

		return RES_OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// El bloque queda vacio, podemos liberarlo?
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		int posTabla_atras = (posTabla - bloque.td / 2) mod (tabla.tt)
\end_layout

\begin_layout Plain Layout

		int posTabla_adelante = (posTabla - bloque.td / 2) mod (tabla.tt)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if (tabla[posTabla_atras] == tabla[posTabla_adelante):
\end_layout

\begin_layout Plain Layout

			// El bloque se lo puede agregar a "bloques libres"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			bloquesLibres.agregar(numBloque)
\end_layout

\begin_layout Plain Layout

			numBloqueReemplazo = tabla[posTabla_atras]
\end_layout

\begin_layout Plain Layout

			Bloque reemplazo = bloques[numBloqueReemplazo]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			// Se reemplazan sus referencias en la tabla por otro bloque
\end_layout

\begin_layout Plain Layout

			int punteroInicial = numBLoque
\end_layout

\begin_layout Plain Layout

			while (tabla[punteroInicial] != numBloqueReemplazo)
\end_layout

\begin_layout Plain Layout

				tabla[punteroInicial] = numBloqueReemplazo
\end_layout

\begin_layout Plain Layout

				punteroInicial = (punteroInicial + reemplazo.td) mod (tabla.tt)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			reemplazo.td /= 2
\end_layout

\begin_layout Plain Layout

			if (tabla.mitadesIguales())
\end_layout

\begin_layout Plain Layout

				tabla.cortarPorMitad()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			// No se puede marcar como libre, queda vacio
\end_layout

\begin_layout Plain Layout

			return RES_OK
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baja mediante bits sufijos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Mediante bits prefijos
\end_layout

\begin_deeper
\begin_layout Itemize
Las claves se representan de forma binaria.
 
\end_layout

\begin_layout Itemize
La función de hash devuelve los 
\begin_inset Formula $\log_{2}(tabla.tt)$
\end_inset

 bits menos significativos de la clave, en base 10.
 
\begin_inset Formula 
\[
f(clave)=\left(clave_{\left[\log_{2}\left(tabla.tt\right),\ldots,0\right]}\right)_{10}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

	int posTabla = fhash(registro.clave)
\end_layout

\begin_layout Plain Layout

	int numeroBloque = tabla[posTabla]
\end_layout

\begin_layout Plain Layout

	Bloque bloque = bloques[numeroBloque]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.contiene(registro.clave))
\end_layout

\begin_layout Plain Layout

		return RES_REGISTRO_DUPLICADO
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.cantRegsLibres < tabla.cantRegsPorBloque)
\end_layout

\begin_layout Plain Layout

		bloque.insertar(registro)
\end_layout

\begin_layout Plain Layout

		return RES_OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// La clave no esta en el bloque y no se puede insertar en el
\end_layout

\begin_layout Plain Layout

	// El bloque aparece referenciado en la tabla solo 1 vez
\end_layout

\begin_layout Plain Layout

	if (bloque.td == tabla.tt)
\end_layout

\begin_layout Plain Layout

		tabla.duplicar() // Elemento a elemento
\end_layout

\begin_layout Plain Layout

		tabla.tt *= 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Bloque nuevoBloque // Uno nuevo o el primero de bloquesLibres
\end_layout

\begin_layout Plain Layout

		bloques.agregar(nuevoBloque) // Si cree uno nuevo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		bloque.td *= 2
\end_layout

\begin_layout Plain Layout

		nuevoBloque.td = bloque.td
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Actualizo la referencia en la tabla
\end_layout

\begin_layout Plain Layout

		tabla[posTabla] = numNuevoBloque
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// La clave no esta en el bloque y no se puede insertar en el
\end_layout

\begin_layout Plain Layout

	// El bloque aparece referenciado en la tabla mas de 1 vez
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		int viejoTT = tabla.tt
\end_layout

\begin_layout Plain Layout

		Bloque nuevoBloque // Uno nuevo o el primero de bloquesLibres
\end_layout

\begin_layout Plain Layout

		bloques.agregar(nuevoBloque) // Si cree uno nuevo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		bloque.td *= 2
\end_layout

\begin_layout Plain Layout

		nuevoBloque.td = bloque.td
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Actualizo las referencias en la tabla
\end_layout

\begin_layout Plain Layout

		int punteroInicial = 0
\end_layout

\begin_layout Plain Layout

		while (punteroInicial != viejoTT)
\end_layout

\begin_layout Plain Layout

			if (tabla[punteroInicial] == numBloque)
\end_layout

\begin_layout Plain Layout

				tabla[punteroInicial] = numNuevoBloque
\end_layout

\begin_layout Plain Layout

			punteroInicial += 1			
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

	bloque.redispersar()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	insertar(registro, tabla, bloques)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Alta mediante bits prefijos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	int posTabla = funcionMod(registro.clave)
\end_layout

\begin_layout Plain Layout

	int numeroBloque = tabla[posTabla]
\end_layout

\begin_layout Plain Layout

	Bloque bloque = bloques[numeroBloque]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (! bloque.contiene(registro.clave))
\end_layout

\begin_layout Plain Layout

		return RES_REGISTRO_NO_EXISTE
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (bloque.cantRegsLibres > 1)
\end_layout

\begin_layout Plain Layout

		bloque.eliminar(registro)
\end_layout

\begin_layout Plain Layout

		return RES_OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// El bloque queda vacio, ¿podemos liberarlo?
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		// Calculo el vector donde posiblemente haya bloques de reemplazo
\end_layout

\begin_layout Plain Layout

		vector<int> posicionesTabla
\end_layout

\begin_layout Plain Layout

		int cantBitsEspacioBusqueda = log(tabla.tt,2)
\end_layout

\begin_layout Plain Layout

		int cantBitsPrefijoClave = log(bloque.td,2)
\end_layout

\begin_layout Plain Layout

		claveConUltimoBitPermutado = clave.permutarUltimoBit()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		int cantidadVariantes = cantBitsEspacioBusqueda - cantBitsPrefijoClave
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < 2; i ++)
\end_layout

\begin_layout Plain Layout

			variante = getNextPermutacion (cantidadVariantes)
\end_layout

\begin_layout Plain Layout

			posicionesTabla.agregar(claveConUltimoBitPermutado + variante)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if (bloque.td == tabla.tt)
\end_layout

\begin_layout Plain Layout

			// El bloque se lo puede agregar a "bloques libres"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			bloquesLibres.agregar(numBloque)
\end_layout

\begin_layout Plain Layout

			numBloqueReemplazo = tabla[posicionesTabla(1)]
\end_layout

\begin_layout Plain Layout

			Bloque reemplazo = bloques[numBloqueReemplazo]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			// Se reemplaza su referencia en la tabla por otro bloque
\end_layout

\begin_layout Plain Layout

			tabla[numBloque] = numBloqueReemplazo
\end_layout

\begin_layout Plain Layout

			reemplazo.td /= 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			if (tabla[posicionesTabla(1..etc)].elementosIdenticosEntreSi()):
\end_layout

\begin_layout Plain Layout

				// El bloque se lo puede agregar a "bloques libres"
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

				bloquesLibres.agregar(numBloque)
\end_layout

\begin_layout Plain Layout

				numBloqueReemplazo = tabla[posicionesTabla(1)]
\end_layout

\begin_layout Plain Layout

				Bloque reemplazo = bloques[numBloqueReemplazo]
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

				// Se reemplazan sus referencias en la tabla por otro bloque
\end_layout

\begin_layout Plain Layout

				int punteroInicial = numBLoque
\end_layout

\begin_layout Plain Layout

				while (tabla[punteroInicial] != numBloqueReemplazo)
\end_layout

\begin_layout Plain Layout

					tabla[punteroInicial] = numBloqueReemplazo
\end_layout

\begin_layout Plain Layout

					punteroInicial = (punteroInicial + reemplazo.td) mod (tabla.tt)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

				reemplazo.td /= 2
\end_layout

\begin_layout Plain Layout

				if (tabla.mitadesIguales())
\end_layout

\begin_layout Plain Layout

					tabla.cortarPorMitad()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			else:
\end_layout

\begin_layout Plain Layout

				// No hay bloques de reemplazo, queda vacio.
\end_layout

\begin_layout Plain Layout

				return RES_OK
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Baja mediante bits prefijos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Archivos indexados
\end_layout

\begin_layout Standard

\series bold
Clave
\series default
: expresión derivada de uno o más campos de un registro que se utiliza para
 localizar el mismo.
 Debe ser: 
\end_layout

\begin_layout Itemize
Canónicos: debe haber una sola representación para dos claves similares.
 Ejemplo: 
\begin_inset Quotes eld
\end_inset

The Beatles
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

THE BEATLES
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

the beatles
\begin_inset Quotes erd
\end_inset

 deberían mapear a 
\begin_inset Quotes eld
\end_inset

beatles
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
No cambiante: si el registro cambia y la clave cambia, luego tendrá que
 reorganizarse el archivo.
 
\end_layout

\begin_layout Standard

\series bold
Clave primaria
\series default
: debe ser: 
\end_layout

\begin_layout Itemize
Sin datos: no deben contener información, porque no sabemos si esa información
 podría repetirse en el futuro.
 
\end_layout

\begin_layout Itemize
Única: no puede haber dos registros con la misma clave primaria.
 
\end_layout

\begin_layout Standard

\series bold
Índice
\series default
: herramienta para 
\series bold
buscar registros
\series default
.
 Se basan en los conceptos de 
\begin_inset Quotes eld
\end_inset

clave,referencia
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
Un índice permite imponer orden en un archivo sin tener que ordenar el archivo.
 
\end_layout

\begin_layout Itemize
Un índice permite buscar un registro en un archivo de registros variables
 de forma rápida.
 
\end_layout

\begin_layout Itemize
Varios índices sobre un archivo permiten tener varias formas de acceder
 a un registro.
 
\end_layout

\begin_layout Standard

\series bold
Árbol balanceado
\series default
: la distancia más corta a un nodo hoja difiere en 1 con la distancia más
 larga.
\end_layout

\begin_layout Standard

\series bold
Árbol completamente balanceado
\series default
: todos los caminos desde la raíz hasta un nodo hoja son del mismo largo.
\end_layout

\begin_layout Standard
Para manejar archivos indexados con registros de longitud variable, en vez
 de contar la cantidad de registros que caben en un nodo, se cuenta la cantidad
 de bytes que caben.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

int I_DESTROY (char* nombreArchivo); 
\end_layout

\begin_layout Plain Layout

int I_OPEN (const char* nombreArchivo, int modoApertura);
\end_layout

\begin_layout Plain Layout

int I_CLOSE (int fileHandler); 
\end_layout

\begin_layout Plain Layout

int I_ADD_INDEX(int handler, const campo* clave); 
\end_layout

\begin_layout Plain Layout

int I_DROP_INDEX (int fileHandler, int indexId); 
\end_layout

\begin_layout Plain Layout

int I_IS_INDEX (int fileHandler, campo* clave);
\end_layout

\begin_layout Plain Layout

int I_START (int fileHandler, int indexId, char* operador, const void* valorRefe
rencia); 
\end_layout

\begin_layout Plain Layout

int I_READ (int fileHandler, void* regDestino);
\end_layout

\begin_layout Plain Layout

int I_READNEXT (int fileHandler, int indexId, void* regDestino);
\end_layout

\begin_layout Plain Layout

int I_WRITE (int fileHandler, const void* reg);
\end_layout

\begin_layout Plain Layout

int I_UPDATE (int fileHandler, const void* reg);
\end_layout

\begin_layout Plain Layout

int I_DELETE (int fileHandler, const void* reg);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Primitivas de la organización indexada
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Árbol B (indexado)
\end_layout

\begin_layout Standard

\series bold
Árbol B: 
\series default
estructura que intenta acceder y mantener un índice que es muy grande para
 mantener en memoria.
 
\end_layout

\begin_layout Itemize
Todos los nodos mantienen elementos almacenados.
 El 
\series bold
orden
\series default
 de un árbol B es la cantidad máxima de nodos descendientes que puede tener
 un nodo interno.
 
\end_layout

\begin_layout Itemize
Cantidad de 
\emph on
seeks 
\emph default
necesarias para acceder por referencia a una clave: 
\begin_inset Formula 
\[
1+\log_{\left\lceil \frac{k}{2}\right\rceil }\left(\frac{n+1}{2}\right)
\]

\end_inset

donde 
\begin_inset Formula $k=$
\end_inset

 cantidad de registros lógicos, 
\begin_inset Formula $n=$
\end_inset

 factor de bloqueo.
 
\end_layout

\begin_layout Itemize
Son árboles anchos y poco profundos.
 Todas las ramas tienen igual profundidad.
 
\end_layout

\begin_layout Itemize
Cada 
\series bold
nodo
\series default
 del árbol posee:
\end_layout

\begin_deeper
\begin_layout Itemize
Claves: 
\begin_inset Formula $k$
\end_inset

 como máximo, 
\begin_inset Formula $\left\lfloor \frac{k}{2}\right\rfloor $
\end_inset

 como mínimo.
 
\end_layout

\begin_layout Itemize
Punteros a nodos descendientes: 
\begin_inset Formula $k+1$
\end_inset

 como máximo, 
\begin_inset Formula $\left\lceil \frac{k+1}{2}\right\rceil $
\end_inset

 como mínimo.
 
\end_layout

\end_deeper
\begin_layout Itemize
La 
\series bold
raíz
\series default
 puede no tener claves (si el árbol está vacío), y puede tener 0 descendientes,
 o más de 2.
 
\end_layout

\begin_layout Itemize
Los nodos 
\series bold
hoja
\series default
 no tienen descendientes.
 
\end_layout

\begin_layout Itemize
Entre la cantidad mínima de claves y la cantidad mínima de descendientes,
 hay una diferencia de 1.
 
\end_layout

\begin_layout Itemize
El árbol está 
\series bold
ordenado
\series default
 por clave.
 Cada clave en un nodo tiene dos referencias: una a un nodo con elementos
 de clave menor, y otra a un nodo con elementos de clave mayor.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	BTreeNode root
\end_layout

\begin_layout Plain Layout

	root.isLeaf = true
\end_layout

\begin_layout Plain Layout

	root.elements = 0
\end_layout

\begin_layout Plain Layout

	disk-write(root)
\end_layout

\begin_layout Plain Layout

	this->root = root
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

BTreeNode BTree::search (motherNode, key):
\end_layout

\begin_layout Plain Layout

	if motherNode.contains(key):
\end_layout

\begin_layout Plain Layout

		return motherNode
\end_layout

\begin_layout Plain Layout

	if motherNode.isLeaf():
\end_layout

\begin_layout Plain Layout

		return NULL // Key not found
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	BTreeNode nextToFind = NULL
\end_layout

\begin_layout Plain Layout

	for each keyi in motherNode:
\end_layout

\begin_layout Plain Layout

		if motherNode[keyi] > key:
\end_layout

\begin_layout Plain Layout

			// Element with next higher key
\end_layout

\begin_layout Plain Layout

			nextToFind = motherNode[keyi].leftPointer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Element with node's max key
\end_layout

\begin_layout Plain Layout

	nextToFind = motherNode[maxKey].rightPointer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return (search (nextToFind, key))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	BTreeNode leafNode = search(key)
\end_layout

\begin_layout Plain Layout

	if (leafNode.isFull())
\end_layout

\begin_layout Plain Layout

		// Split
\end_layout

\begin_layout Plain Layout

		BTreeSuperNode supernode = leafNode
\end_layout

\begin_layout Plain Layout

		supernode.insert(key)
\end_layout

\begin_layout Plain Layout

		supernode.split()  // 2-3 o 3-2	
\end_layout

\begin_layout Plain Layout

		supernode.promote(median) //More splits may be necessary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		leafNode.insert(key)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	BTreeNode node = find(this->root,key)
\end_layout

\begin_layout Plain Layout

	if (node == NULL)
\end_layout

\begin_layout Plain Layout

		return false
\end_layout

\begin_layout Plain Layout

	if (node.isLeaf())
\end_layout

\begin_layout Plain Layout

		node.delete(key)
\end_layout

\begin_layout Plain Layout

		if (node.underflow())
\end_layout

\begin_layout Plain Layout

			if (node.sibling.hasExtraKeys())
\end_layout

\begin_layout Plain Layout

				// Bajar uno del padre al nodo y
\end_layout

\begin_layout Plain Layout

				// subir uno del sibling al padre.
\end_layout

\begin_layout Plain Layout

				// El sibling es siempre el izquierdo o siempre el derecho
\end_layout

\begin_layout Plain Layout

				node.redistributeWithSibling(node.sibling)
\end_layout

\begin_layout Plain Layout

			else:
\end_layout

\begin_layout Plain Layout

				// Juntar dos nodos en uno y bajar el separador del padre
\end_layout

\begin_layout Plain Layout

				node.concatenateWith(node.sibling, node.father)
\end_layout

\begin_layout Plain Layout

				if (node.father.underflow())
\end_layout

\begin_layout Plain Layout

					node.father.redistributeWithSibling()
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		BTreeNode immediate = node.immediatelySuperiorORinferior()
\end_layout

\begin_layout Plain Layout

		swap(node[key], immediate[key])
\end_layout

\begin_layout Plain Layout

		immediate.delete (key)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Árbol B* (indexado)
\end_layout

\begin_layout Standard
Es una variante del árbol B.
 
\end_layout

\begin_layout Itemize
Cada 
\series bold
nodo
\series default
 del árbol posee:
\end_layout

\begin_deeper
\begin_layout Itemize
Claves: 
\begin_inset Formula $k$
\end_inset

 como máximo, 
\begin_inset Formula $\left\lfloor \frac{2}{3}k\right\rfloor $
\end_inset

 como mínimo.
 
\end_layout

\begin_layout Itemize
Punteros a nodos descendientes: 
\begin_inset Formula $k+1$
\end_inset

 como máximo, 
\begin_inset Formula $\left\lceil \frac{2k+1}{3}\right\rceil $
\end_inset

 como mínimo.
 
\end_layout

\end_deeper
\begin_layout Itemize
Se realizan redistribuciones en el alta.
 
\end_layout

\begin_layout Itemize
Los split se realizan tomando 2 
\emph on
siblings
\emph default
 y dividiéndolos en 3 nodos, donde cada uno tiene una carga de 
\begin_inset Formula $\frac{2}{3}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
La 
\series bold
raíz
\series default
 es un 
\series bold
caso especial
\series default
, porque no tiene 
\emph on
siblings
\emph default
.
 Entonces, para hacer un split de la raíz, puede elegirse entre las siguientes
 alternativas:
\end_layout

\begin_deeper
\begin_layout Itemize
Manejar la raíz como un nodo de un árbol B 
\end_layout

\begin_layout Itemize
Raíz con más capacidad que los demás nodos, para que cuando hagamos un split,
 los dos nodos resultantes estén 
\begin_inset Formula $\frac{2}{3}$
\end_inset

 llenos, 
\end_layout

\begin_layout Itemize
Raíz con mucha más capacidad que los demás nodos, para que cuando hagamos
 un split, los tres nodos resultantes estén 
\begin_inset Formula $\frac{2}{3}$
\end_inset

 llenos 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Ventajas con respecto a árbol B
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Desventajas con respecto a árbol B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Menor altura del árbol, y por ende menor tiempo de búsqueda 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Altas y bajas más costosas, porque se redistribuye
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aprovecha mejor el espacio en el nodo 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Árbol B+ (indexado secuencial)
\end_layout

\begin_layout Itemize
Es una combinación entre un set indexado y un set secuencial.
 Por lo tanto, provee acceso 
\series bold
secuencial 
\series default
e 
\series bold
indexado
\series default
.
 
\end_layout

\begin_layout Itemize
El set secuencial está formado por 
\series bold
bloques
\series default
 (no necesariamente contiguos físicamente en disco) que contienen registros
 ordenados, y dos punteros (uno al bloque anterior, y uno al siguiente).
 
\end_layout

\begin_layout Itemize
El set indexado es un índice al set secuencial.
 Es un árbol B que contiene:
\end_layout

\begin_deeper
\begin_layout Itemize
Registros de 
\series bold
longitud fija 
\series default
(usualmente del mismo tamaño de los bloques del set secuencial) que tienen
 
\series bold
claves
\series default
 para distinguir entre dos bloques.
 Cada nodo contiene 
\begin_inset Formula $N$
\end_inset

 separadores y 
\begin_inset Formula $N+1$
\end_inset

 descendientes.
 
\end_layout

\begin_layout Standard
ó 
\end_layout

\begin_layout Itemize
Registros de longitud variable que tienen:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/index_set_variable_record.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Index set block
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Contador de separadores (para poder hacer una búsqueda binaria sobre los
 mismos) 
\end_layout

\begin_layout Itemize
Longitud total de los separadores (para poder acceder al índice de separadores)
 
\end_layout

\begin_layout Itemize
Separadores concatenados 
\end_layout

\begin_layout Itemize
Índice a los separadores (la longitud de cada separador se obtiene con el
 puntero siguiente 
\end_layout

\begin_layout Itemize
Puntero a otros bloques 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	BPlusTreeBlock block = findSequentialSetBlock(key)
\end_layout

\begin_layout Plain Layout

	if (block + key = overflow):
\end_layout

\begin_layout Plain Layout

		block.split() // no se promueven claves, se distribuyen en 2 bloques
\end_layout

\begin_layout Plain Layout

		// Actualizar index set
\end_layout

\begin_layout Plain Layout

		if (node of index set in overflow)
\end_layout

\begin_layout Plain Layout

			// resolver como en arbol B.
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		block.insert(key)
\end_layout

\begin_layout Plain Layout

		// Actualizar index set si corresponde.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	BPlusTreeBlock block = findSequentialSetBlock(key)
\end_layout

\begin_layout Plain Layout

	if (block - key = underflow):
\end_layout

\begin_layout Plain Layout

		if (block.rightNeighbour.load =  1/2)
\end_layout

\begin_layout Plain Layout

			concat(block, block.rightNeighbour)
\end_layout

\begin_layout Plain Layout

			markDeleted(block) // Con un mapa de bits
\end_layout

\begin_layout Plain Layout

			// Actualizar index set
\end_layout

\begin_layout Plain Layout

			indexset.remove(separator)
\end_layout

\begin_layout Plain Layout

		if (block.neighbors.load > 1/2)
\end_layout

\begin_layout Plain Layout

			redistributeLoad(block,block.neighbors)
\end_layout

\begin_layout Plain Layout

			indexset.update(separator)
\end_layout

\begin_layout Plain Layout

	else:
\end_layout

\begin_layout Plain Layout

		block.delete(key)
\end_layout

\begin_layout Plain Layout

		// El index set no cambia.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Árbol B# (indexado secuencial)
\end_layout

\begin_layout Section
Ordenamiento de archivos
\end_layout

\begin_layout Standard
Se tiene un archivo formado por registros con claves.
 Los registros están desordenados.
 Se lo quiere ordenar.
 
\end_layout

\begin_layout Enumerate

\series bold
Métodos Internos
\series default
: el tamaño del archivo no puede ser mayor al tamaño de la memoria disponible.
\end_layout

\begin_deeper
\begin_layout Enumerate
Heapsort 
\end_layout

\begin_layout Enumerate
Quicksort 
\end_layout

\begin_layout Enumerate
Keysort: la suma de los tamaños de las claves de los registros no puede
 ser mayor al tamaño de la memoria disponible.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<pair<Clave,Puntero>> claves = archivoDesordenado.getClaves()
\end_layout

\begin_layout Plain Layout

	claves.sort() // Ordenar por Clave
\end_layout

\begin_layout Plain Layout

	for parClavePuntero in claves:
\end_layout

\begin_layout Plain Layout

		Registro registro = archivoDesordenado.getRegistro(parClavePuntero.second)
\end_layout

\begin_layout Plain Layout

		archivoOrdenado.append(registro)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Problema: Hay que leer el archivo dos veces, y la segunda lectura no es
 en forma secuencial.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Métodos Externos
\series default
: se carga el archivo parcialmente en memoria, se ordena, se graban copias
 (
\begin_inset Quotes eld
\end_inset

particiones
\begin_inset Quotes erd
\end_inset

) y luego se hace 
\emph on
merge
\emph default
 de estas particiones.
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Mergesort
\series default
: genera particiones del tamaño de la memoria.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Registro registroLeido = archivoDesordenado.getNextRegistro()
\end_layout

\begin_layout Plain Layout

	registrosLeidos.append(registroLeido)
\end_layout

\begin_layout Plain Layout

	memoriaLibre = memoriaLibre - registroLeido.tamanio
\end_layout

\begin_layout Plain Layout

	cantRegsLeidos ++
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

archTempOrdenado _generarParticion(archivoDesordenado, cantRegsArchivo,
 cantRegsLeidos, tamanioMemoria)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<Registro>* registrosLeidos = new Vector()
\end_layout

\begin_layout Plain Layout

	int memoriaLibre = tamanioMemoria
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (cantRegsLeidos < cantRegsArchivo)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		agregarRegistroAmemoria (archivoDesordenado, *registrosLeidos, &cantRegsLeidos
, &memoriaLibre)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		while (cantRegsLeidos < cantRegsArchivo && memoriaLibre > registroLeido->taman
io())
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

				agregarRegistroAmemoria (archivoDesordenado, *registrosLeidos, &cantRegsLeid
os, &memoriaLibre)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	registrosLeidos.sort()
\end_layout

\begin_layout Plain Layout

	archTempOrdenado.agregar(registrosLeidos)
\end_layout

\begin_layout Plain Layout

	delete(registrosLeidos)  // Libero la memoria
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void mergesort (archivoDesordenado, archivoOrdenado)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int cantRegsArchivo = archivoDesordenado.getCantRegs()
\end_layout

\begin_layout Plain Layout

	int cantRegsLeidos = 0
\end_layout

\begin_layout Plain Layout

	vector<archTempOrdenado> particiones //referencias a archivos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Genero las particiones
\end_layout

\begin_layout Plain Layout

	while (cantRegsLeidos < cantRegsArchivo)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		archTempOrdenado = _generarParticion(archivoDesordenado,cantRegsArchivo,
 &cantRegsLeidos, tamanioMemoria)
\end_layout

\begin_layout Plain Layout

		particiones->append(archTempOrdenado)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	mergePolifasico(particiones, archivoOrdenado)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mergesort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Mergesort con Replacement Selection
\series default
: usa dos 
\emph on
heaps.
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Mejor caso
\bar default
: archivo ordenado.
 Genera una partición del tamaño del archivo.
\end_layout

\begin_layout Standard

\bar under
Peor caso
\bar default
: archivo ordenado en forma inversa.
 Particiones de tamaño 
\begin_inset Formula $tama\tilde{n}o\, memoria$
\end_inset

 como un sort interno.
\end_layout

\begin_layout Standard

\bar under
Caso medio
\bar default
: archivo con orden aleatorio.
 Particiones de tamaño 
\begin_inset Formula $2*\, tama\tilde{n}o\, memoria$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
ARCHIVO = 2,1,3,5,7,8,2,6,4,1,2,0,3,5
\end_layout

\begin_layout Plain Layout
Tamaño registro = 1 byte, Tamaño RAM = 3 bytes
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Lectura
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Heap primario en memoria
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Heap secundario en memoria
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Salida
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
Comentarios
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,1,3 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,3,5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,5,7 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 es menor a 5, va al heap secundario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 es menor a 7, va al heap secundario.
 Se vació el heap primario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El heap 2 pasa a memoria
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 es menor a 2, va al heap secundario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 es menor a 4, va al heap secundario.
 Se vació el heap primario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El heap 2 pasa a memoria
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,1,2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,3,5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se terminó el archivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vaciamos el heap primario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vaciamos el heap primario
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ejemplo de Replacement Selection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<archivoOrdenado> particiones
\end_layout

\begin_layout Plain Layout

	vector<Registro> registros = llenarMemoria(tamanioMemoria, archivoDesordenado)
\end_layout

\begin_layout Plain Layout

	Heap heapPrimario (registros) 
\end_layout

\begin_layout Plain Layout

	Heap heapSecundario () // Aca se guardan los registros congelados
\end_layout

\begin_layout Plain Layout

	archivoOrdenado
\end_layout

\begin_layout Plain Layout

	particiones.agregar(archivoOrdenado)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	bool hayMasRegistros = !archivoDesordenado.eof()
\end_layout

\begin_layout Plain Layout

	mientras (hayMasRegistros && ! heapPrimario.vacio())
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		Registro regMinimo = heapPrimario.quitarMinimo()
\end_layout

\begin_layout Plain Layout

		archivoOrdenado.agregar(regMinimo)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			si (heapPrimario.vacio()
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				archivoOrdenado.close()
\end_layout

\begin_layout Plain Layout

				archivoOrdenado = open(nuevo archivoOrdenado)
\end_layout

\begin_layout Plain Layout

				particiones.agregar(archivoOrdenado)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				vector<Registro> registros = llenarMemoria(tamanioMemoria, heapSecundario)
\end_layout

\begin_layout Plain Layout

				Heap heapPrimario (registros) 
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Registro regLeido = archivoDesordenado.getNextRegistro()
\end_layout

\begin_layout Plain Layout

		si (regLeido.clave < regMinimo.clave)
\end_layout

\begin_layout Plain Layout

			heapSecundario.insertar(regLeido)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		si (regLeido.clave > regMinimo.clave)
\end_layout

\begin_layout Plain Layout

			heapPrimario.insertar(regLeido)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return particiones
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void mergesort(archivoDesordenado, particiones, archivoOrdenado, tamanioMemoria)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<archivoOrdenado> particiones = replacementSelection(archivoDesordenado,
 tamanioMemoria)
\end_layout

\begin_layout Plain Layout

	mergepolifasico(particiones,archivoOrdenado)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Replacement Selection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Mergesort con Natural Selection:
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Mejor caso
\bar default
:
\end_layout

\begin_layout Standard

\bar under
Peor caso
\bar default
:
\end_layout

\begin_layout Standard

\bar under
Caso medio
\bar default
: archivo con orden aleatorio.
 Particiones de tamaño 
\begin_inset Formula $3*\, tama\tilde{n}o\, memoria$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
ARCHIVO = 2,1,3,5,7,8,2,6,4,1,2,0,3,5
\end_layout

\begin_layout Plain Layout
Tamaño registro = 1 byte, Tamaño RAM = 3 bytes
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="20" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Lectura
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memoria
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Freezer (archivo)
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Salida
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
Comentarios
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,1,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,1,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Llenamos la memoria
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,5,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,5,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,5,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 es menor a 5, va al freezer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 es menor a 6, va al freezer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 es menor a 6, va al freezer (que se llena)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vaciamos la memoria ordenadamente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vaciamos la memoria ordenadamente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El freezer pasa a memoria
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 es menor a 2, va al freezer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,4,3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El archivo se terminó.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Copiamos lo del freezer a memoria.
 Nueva partición.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ejemplo de Natural Selection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<archivoOrdenado> particiones
\end_layout

\begin_layout Plain Layout

	vector<Registro> registros = llenarMemoria(tamanioMemoria, archivoDesordenado)
\end_layout

\begin_layout Plain Layout

	Heap heap (registros) 
\end_layout

\begin_layout Plain Layout

	archivoOrdenado archivoOrdenado
\end_layout

\begin_layout Plain Layout

	particiones.agregar(archivoOrdenado)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	archivoOrdenado freezer (tamanioMemoria) // Aca se guardan los registros
 congelados
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	bool hayMasRegistros = !archivoDesordenado.eof()
\end_layout

\begin_layout Plain Layout

	mientras (hayMasRegistros)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Registro regMinimo = heap.quitarMinimo()
\end_layout

\begin_layout Plain Layout

		archivoOrdenado.agregar(regMinimo)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Registro regLeido = archivoDesordenado.getNextRegistro()
\end_layout

\begin_layout Plain Layout

		si (regLeido.clave < regMinimo.clave)
\end_layout

\begin_layout Plain Layout

			heap.insertar(regLeido)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		si (regLeido.clave > regMinimo.clave)
\end_layout

\begin_layout Plain Layout

			freezer.agregar(regLeido)
\end_layout

\begin_layout Plain Layout

			si (freezer.lleno())
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				while (! heap.vacio())
\end_layout

\begin_layout Plain Layout

					regMinimo = heap.quitarMinimo()
\end_layout

\begin_layout Plain Layout

					archivoOrdenado.agregar(regMinimo)
\end_layout

\begin_layout Plain Layout

					registros = llenarMemoria(tamanioMemoria, freezer)
\end_layout

\begin_layout Plain Layout

					heap (registros) 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	si (! freezer.vacio()) //Quedaron registros sin grabar a disco
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		vector<Registro> registros = llenarMemoria(tamanioMemoria, freezer)
\end_layout

\begin_layout Plain Layout

		registros.sort()
\end_layout

\begin_layout Plain Layout

		particiones.agregar(archivoOrdenado(registros))
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return particiones
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void mergesort(archivoDesordenado, particiones, archivoOrdenado, tamanioMemoria)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	vector<archivoOrdenado> particiones = naturalSelection(archivoDesordenado,
 tamanioMemoria)
\end_layout

\begin_layout Plain Layout

	mergepolifasico(particiones,archivoOrdenado)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Natural Selection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Radix Sort
\series default
: solo sirve para ordenar números enteros.
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Mejor caso
\bar default
 = 
\bar under
peor caso
\bar default
 = 
\bar under
caso medio
\bar default
 = 
\begin_inset Formula $O(nk)$
\end_inset

, donde 
\begin_inset Formula $n$
\end_inset

 es la cantidad de elementos y 
\begin_inset Formula $k$
\end_inset

 es la cantidad máxima de dígitos de los números.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/Radix-sort.png
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Radix Sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Bucket Sort
\series default
: ordena eficientemente 
\begin_inset Formula $n$
\end_inset

 números, donde cada número pertenece al rango 
\begin_inset Formula $[0..N-1]$
\end_inset

, y 
\begin_inset Formula $N$
\end_inset

 no es mucho más grande que 
\begin_inset Formula $n$
\end_inset

, o 
\begin_inset Formula $N<n$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/bucketSort.png
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bucket Sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Operaciones entre 2 o más archivos
\end_layout

\begin_layout Subsection
Intersección (
\emph on
match
\emph default
)
\end_layout

\begin_layout Standard
Se tienen dos archivos ordenados por clave.
 Se quiere obtener un archivo que contenga los registros que están en ambos
 archivos.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	boolean masElementos = proximoItem(lista1) && proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

	mientras (masElementos):
\end_layout

\begin_layout Plain Layout

		si (item(lista1) < item(lista2)):
\end_layout

\begin_layout Plain Layout

			masElementos = proximoItem(lista1)
\end_layout

\begin_layout Plain Layout

		si (item(lista1) > item(lista2)):
\end_layout

\begin_layout Plain Layout

			masElementos = proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

		si (item(lista1) == item(lista2)):
\end_layout

\begin_layout Plain Layout

			salida.agregar(item(lista1))
\end_layout

\begin_layout Plain Layout

		masElementos = proximoItem(lista1) && proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Unión (
\emph on
merge
\emph default
)
\end_layout

\begin_layout Standard
Se tienen dos archivos ordenados por clave.
 Se quiere obtener un archivo que contenga los registros que están en uno
 o en ambos archivos.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	boolean masElementosLista1 = proximoItem(lista1) 
\end_layout

\begin_layout Plain Layout

	boolean masElementosLista2 = proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

	mientras (masElementosLista1 || masElementosLista2):
\end_layout

\begin_layout Plain Layout

		si (item(lista1) < item(lista2)):
\end_layout

\begin_layout Plain Layout

			salida.agregar(item(lista1))
\end_layout

\begin_layout Plain Layout

			masElementos = proximoItem(lista1)
\end_layout

\begin_layout Plain Layout

		si (item(lista1) > item(lista2)):
\end_layout

\begin_layout Plain Layout

			salida.agregar(item(lista2))
\end_layout

\begin_layout Plain Layout

			masElementos = proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

		si (item(lista1) == item(lista2)):
\end_layout

\begin_layout Plain Layout

			salida.agregar(item(lista1))
\end_layout

\begin_layout Plain Layout

			masElementosLista1 = proximoItem(lista1) 
\end_layout

\begin_layout Plain Layout

			masElementosLista2 = proximoItem(lista2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\emph on
Merge
\emph default
 de k vías
\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: hacer la unión de 
\begin_inset Formula $k$
\end_inset

 archivos, donde 
\begin_inset Formula $k\leq8$
\end_inset

.
\end_layout

\begin_layout Standard

\bar under
Entrada
\bar default
: 
\begin_inset Formula $k$
\end_inset

 listas ordenadas, cada una de tamaño 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard

\bar under
Salida
\bar default
: lista de tamaño 
\begin_inset Formula $nk$
\end_inset


\end_layout

\begin_layout Standard

\bar under
Orden
\bar default
: 
\begin_inset Formula $O(nk^{2})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

	// Crear lista de indices
\end_layout

\begin_layout Plain Layout

	int indices[1..k] = 0
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	int contador = 0
\end_layout

\begin_layout Plain Layout

	mientras (contador < kn):
\end_layout

\begin_layout Plain Layout

		// Obtener el numero de lista 
\end_layout

\begin_layout Plain Layout

		// cuyo proximo elemento sin procesar es el minimo
\end_layout

\begin_layout Plain Layout

		// (ignora listas para las cuales indices[j] > n)
\end_layout

\begin_layout Plain Layout

		para cada j entre 1 y k:
\end_layout

\begin_layout Plain Layout

			int minimo = min (listas[j][indices[j]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		salida[contador] = listas[p][indices[p]]
\end_layout

\begin_layout Plain Layout

		indice[p] += 1
\end_layout

\begin_layout Plain Layout

		contador += 1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Apareo
\end_layout

\begin_layout Standard
Se tiene un archivo 
\begin_inset Quotes eld
\end_inset

maestro
\begin_inset Quotes erd
\end_inset

 y un archivo 
\begin_inset Quotes eld
\end_inset

transaccional
\begin_inset Quotes erd
\end_inset

 que reporta cambios sobre el 
\begin_inset Quotes eld
\end_inset

maestro
\begin_inset Quotes erd
\end_inset

.
 Los archivos están ordenados por la misma clave y tienen el mismo formato
 de registro, con la excepción de que los registros de los archivos 
\begin_inset Quotes eld
\end_inset

transaccionales
\begin_inset Quotes erd
\end_inset

 deben tener un campo extra que indique si es una transacción 
\begin_inset Quotes eld
\end_inset

alta
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

baja
\begin_inset Quotes erd
\end_inset

, o 
\begin_inset Quotes eld
\end_inset

modificación
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

	boolean masRegistrosMaestros = proximoItem(listaMaestra) 
\end_layout

\begin_layout Plain Layout

	boolean masRegistrosTransacc = proximoItem(listaTransacciones)
\end_layout

\begin_layout Plain Layout

	mientras (masRegistrosMaestros || masRegistrosTransacc)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		si (item(listaMaestra) < item(listaTransacciones))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			salida.agregar(item(listaMaestra))
\end_layout

\begin_layout Plain Layout

			masRegistrosMaestros = proximoItem(listaMaestra) 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		si (item(listaMaestra) > item(listaTransacciones))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			si (operacion(item(listaTransacciones)) == "alta"):
\end_layout

\begin_layout Plain Layout

				salida.agregar(item(listaTransacciones))
\end_layout

\begin_layout Plain Layout

			si (operacion(item(listaTransacciones)) == "baja"):
\end_layout

\begin_layout Plain Layout

				mostrar(ERROR EN BORRADO POR REGISTRO INEXISTENTE)
\end_layout

\begin_layout Plain Layout

			si (operacion(item(listaTransacciones)) == "modificacion"):
\end_layout

\begin_layout Plain Layout

				mostrar(ERROR EN MODIFICACION POR REGISTRO INEXISTENTE)
\end_layout

\begin_layout Plain Layout

			masRegistrosTransacc = proximoItem(listaTransacciones)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		si (item(listaMaestra) == item(listaTransacciones))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			si (operacion(item(listaTransacciones)) == "alta"):
\end_layout

\begin_layout Plain Layout

				mostrar(ERROR EN ALTA POR REGISTRO DUPLICADO)
\end_layout

\begin_layout Plain Layout

			si (operacion(item(listaTransacciones)) == "modificacion"):
\end_layout

\begin_layout Plain Layout

				salida.agregar(item(listaTransacciones)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			masRegistrosMaestros = proximoItem(listaTransaccionesMaestra)
\end_layout

\begin_layout Plain Layout

			masRegistrosTransacc = proximoItem(listaTransacciones)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
FTRS (
\emph on
Full Text Retrieval System
\emph default
)
\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: encontrar material de naturaleza no estructurada, que satisface una necesidad
 de información, en una colección muy grande.
 La necesidad de información se expresa en una 
\emph on
query
\emph default
, y se quiere ordenar los documentos de más a menos relevantes, y presentarle
 al usuario un subconjunto de los más relevantes.
 
\end_layout

\begin_layout Itemize
Los documentos no tienen estructura clara.
 No hay campos definidos.
\end_layout

\begin_layout Itemize
No existe una respuesta correcta para una consulta.
 
\end_layout

\begin_layout Itemize
Cada documento puede ser más o menos relevante a una consulta.
 La relevancia es subjetiva.
 
\end_layout

\begin_layout Itemize
No sólo importa la velocidad de respuesta sino la calidad de la respuesta.
 
\end_layout

\begin_layout Itemize
Se intenta buscar una aproximación a lo que el usuario pide.
 
\end_layout

\begin_layout Standard

\series bold
Término
\series default
: unidad mínima de información consultable.
\end_layout

\begin_layout Standard

\series bold
Documento
\series default
: unidad mínima de información recuperable.
 Puede ser un un capítulo o un párrafo, una página web, o un libro completo.
\end_layout

\begin_layout Standard

\series bold
Colección
\series default
: puede ser homogénea (es decir, todos los documentos tratan de un tema)
 o no homogéneas (por ejemplo, la Web).
\end_layout

\begin_layout Standard
Etapas para alcanzar el objetivo: 
\end_layout

\begin_layout Enumerate
Elegir el 
\series bold
modelo
\series default
 que permita calcular la relevancia de un documento frente a una consulta.
 
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
"Cómo adivinar lo que el usuario quiso preguntar
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Diseñar algoritmos y estructuras de datos que lo implementen de forma eficiente
 (
\series bold
índice
\series default
).
 
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
"Cómo no tardar demasiado
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Indexación
\end_layout

\begin_layout Standard
Modelos clásicos:
\end_layout

\begin_layout Itemize
Booleano
\end_layout

\begin_deeper
\begin_layout Itemize
Conjuntos difusos
\end_layout

\begin_layout Itemize
Extendido
\end_layout

\end_deeper
\begin_layout Itemize
Vectorial
\end_layout

\begin_deeper
\begin_layout Itemize
Generalizado
\end_layout

\begin_layout Itemize
LSI (Latent Semantic Indexing)
\end_layout

\begin_layout Itemize
Redes Neuronales
\end_layout

\end_deeper
\begin_layout Itemize
Probabilístico
\end_layout

\begin_deeper
\begin_layout Itemize
Redes bayesianas
\end_layout

\begin_layout Itemize
Redes de inferencia bayesiana
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Índice invertido
\series default
: índice de clasificación de documentos por término.
 En la versión básica, por cada término se tiene la lista de documentos
 en los que aparece el término.
 El conjunto de términos es el 
\series bold
vocabulario
\series default
 o 
\series bold
léxico
\series default
.
 Las listas de cada término son 
\series bold
listas invertidas
\series default
.
\end_layout

\begin_layout Standard
Un índice tiene 
\series bold
granularidad
\series default
, que es la precisión con la que se guardan las posiciones de cada término
 en cada documento (
\emph on
word level, paragraph level, etc.
\emph default
).
\end_layout

\begin_layout Standard
Como regla general, los índices invertidos son mejores a los 
\emph on
signature files
\emph default
 y los 
\emph on
bitmaps
\emph default
 tanto en espacio ocupado como en velocidad de resolución de consultas.
\end_layout

\begin_layout Subsection
Modelo booleano
\end_layout

\begin_layout Standard

\bar under
Formas de implementación
\bar default
: 
\end_layout

\begin_layout Enumerate

\series bold
Índice invertido
\series default
.
 Formadas por dos estructuras:
\end_layout

\begin_deeper
\begin_layout Enumerate
Vocabulario: Estructura de búsqueda.
 Suele ser un árbol 
\begin_inset Formula $B$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
<\mbox{i(termino),\ensuremath{freq_{t}}, offset lista invertida}>
\]

\end_inset


\end_layout

\begin_layout Standard
La frecuencia de cada término se almacena aquí para resolver las consultas
 más eficientemente (sin tener que acceder a sus listas invertidas), del
 término menos a más frecuente.
\end_layout

\end_deeper
\begin_layout Enumerate
Listas Invertidas: una por cada término, contiene una lista 
\series bold
ordenada de forma ascendente
\series default
 de los 
\series bold
números
\series default
 de documentos donde se encuentra ese término.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
<d_{1},d_{2},\ldots,d_{freq_{t}}>
\]

\end_inset


\end_layout

\begin_layout Standard
Si el índice es posicional:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
<\left\{ d_{1},freq_{t_{d_{1}}},\left[pos_{1},\ldots,pos_{freq_{t_{d_{1}}}}\right]\right\} ;\ldots;\left\{ d_{freq_{t}},freq_{t_{d_{freq_{t}}}},\left[pos_{1},\ldots,pos_{freq_{t_{d_{freq_{t}}}}}\right]\right\} >
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

indice de archivos = {}
\end_layout

\begin_layout Plain Layout

archivo temporal = {}
\end_layout

\begin_layout Plain Layout

archivo de lexico = {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada "doc" en coleccion:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	indice de archivos += <num doc, doc>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	para cada palabra en doc:
\end_layout

\begin_layout Plain Layout

		si palabra es termino indexable:
\end_layout

\begin_layout Plain Layout

			si termino no esta en lexico:
\end_layout

\begin_layout Plain Layout

				archivo de lexico += termino
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			num termino = posicion de "termino" en "lexico"
\end_layout

\begin_layout Plain Layout

			archivo temporal += <num doc, num termino, pos termino>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	num doc ++
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return archivo temporal // Este archivo esta ordenado por numero de doc
\end_layout

\begin_layout Plain Layout

return lexico // Esto deberia estar en memoria al resolver consultas
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fase 1 de 2: 
\emph on
scanning
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

archivo indice = {}
\end_layout

\begin_layout Plain Layout

archivo invertido de documentos = {}
\end_layout

\begin_layout Plain Layout

archivo invertido de posiciones = {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar "archivo temporal" por "num termino" y luego por "num doc" y luego
 por "pos termino"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num termino actual = primer "num termino"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mientras ("archivo temporal" tenga registros):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	leer <num term, num doc, pos termino>
\end_layout

\begin_layout Plain Layout

	frecuencia = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	mientras (num termino actual == "num term"):
\end_layout

\begin_layout Plain Layout

		lista posiciones += pos termino
\end_layout

\begin_layout Plain Layout

		lista documentos += <num doc, offset lista posiciones>
\end_layout

\begin_layout Plain Layout

		frecuencia ++
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	puntero a indice invertido = ftell(archivo invertido)
\end_layout

\begin_layout Plain Layout

	archivo invertido de documentos += lista documentos
\end_layout

\begin_layout Plain Layout

	archivo indice += <lexico[num term], frecuencia, puntero a indice invertido>	
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fase 2 de 2: 
\emph on
indexing
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Índices de firmas
\series default
 (
\emph on
bitstring signature file
\emph default
): se representa a cada documento mediante una firma única de 
\series bold

\begin_inset Formula $B$
\end_inset

 
\series default
bits.
 Se utilizan 
\begin_inset Formula $N$
\end_inset

 funciones de hash (si 
\begin_inset Formula $N=1$
\end_inset

, debería ser 
\series bold

\begin_inset Formula $B=$
\end_inset

 
\series default
tamaño del léxico).
 Cada función de hash devuelve un valor entre 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $B-1$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Sean:
\end_layout

\begin_layout Itemize
\begin_inset Formula $b$
\end_inset

: cantidad máxima de bitslices a procesar para resolver una consulta
\end_layout

\begin_layout Itemize
\begin_inset Formula $p$
\end_inset

: probabilidad de que un bit de una firma valga 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
p=\sqrt[b]{\left(\frac{z}{N}\right)}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $z$
\end_inset

: cantidad tolerable de falsos positivos en una consulta
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
z=p^{b}\cdot N
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

: cantidad de pares 
\begin_inset Quotes eld
\end_inset

término, documento
\begin_inset Quotes erd
\end_inset

 únicos
\end_layout

\begin_layout Itemize
\begin_inset Formula $q$
\end_inset

: cantidad de términos en una consulta
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

: cantidad de documentos en la colección
\end_layout

\begin_layout Itemize
\begin_inset Formula $B$
\end_inset

: cantidad de funciones de hashing a usar
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
B=\frac{f}{N}\cdot\frac{b}{q}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $W$
\end_inset

: cantidad de bits de la firma
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W=\frac{1}{1-\sqrt[B]{1-p}}
\]

\end_inset


\end_layout

\begin_layout Standard
Receta: 
\begin_inset Formula $W=\frac{V\times B}{0.8}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

para cada doc en coleccion:
\end_layout

\begin_layout Plain Layout

	firma de doc = B bits en cero
\end_layout

\begin_layout Plain Layout

	para cada term en doc:
\end_layout

\begin_layout Plain Layout

		para cada funcion en funcionesHash:
\end_layout

\begin_layout Plain Layout

			numero bit = funcion(term) 
\end_layout

\begin_layout Plain Layout

			encender "numero bit" en la firma de doc //puede haber colisiones!
\end_layout

\begin_layout Plain Layout

	guardar firma de doc en archivo secuencial
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexar mediante índices de firmas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

documentos candidatos = {}
\end_layout

\begin_layout Plain Layout

firma de consulta = B bits en cero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada term de consulta:
\end_layout

\begin_layout Plain Layout

	para cada funcion en funcionesHash:
\end_layout

\begin_layout Plain Layout

		numero bit = funcion(term)
\end_layout

\begin_layout Plain Layout

		encender "numero bit" en la firma de consulta //puede haber colisiones!
\end_layout

\begin_layout Plain Layout

para cada doc de coleccion:
\end_layout

\begin_layout Plain Layout

	si (firma(doc) AND firma de consulta == firma de consulta)
\end_layout

\begin_layout Plain Layout

		documentos candidatos += doc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resultados = revisar(documentos candidatos) // descarto docs que tengan
 falsos positivos
\end_layout

\begin_layout Plain Layout

devolver resultados
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Consultar mediante índices de firmas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No se necesita mantener en memoria el léxico durante la resolución de consultas.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Produce falsos positivos.
 (Para disminuir la cantidad hay que agregar más bits a la firma, o agregar
 más funciones de hash).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Son eficientes para consultas conjuntivas de muchos términos.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No soportan consultas rankeadas.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 o 3 veces más grande que un índice invertido.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se necesita leer todo el archivo para resolver una consulta.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La función de hash debe generar valores distribuidos uniformemente.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Son ineficientes para colecciones donde el tamaño de cada documento es muy
 variable.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Índices de porciones de firmas
\series default
 (
\emph on
bitslice signature file
\emph default
): cada registro 
\begin_inset Formula $i$
\end_inset

 del archivo índice (secuencial) representa los bits en la 
\series bold

\begin_inset Formula $i-$
\end_inset


\series default
ésima posición de la firma de todos los documentos.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

archivo indice = {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada doc en coleccion:
\end_layout

\begin_layout Plain Layout

	para cada term en doc:
\end_layout

\begin_layout Plain Layout

		para cada funcion en funcionesHash:
\end_layout

\begin_layout Plain Layout

			numero bit = funcion(term)
\end_layout

\begin_layout Plain Layout

			archivo temporal += <numero bit, id doc>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar archivo temporal por "numero bit + id doc"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada "numero bit" en archivo temporal:
\end_layout

\begin_layout Plain Layout

	porcion = {}
\end_layout

\begin_layout Plain Layout

	para cada "id doc":
\end_layout

\begin_layout Plain Layout

		encender bit n "id doc" en la porcion
\end_layout

\begin_layout Plain Layout

	archivo indice += porcion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

devolver archivo indice
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexar mediante índices de porciones firmas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

documentos candidatos = {}
\end_layout

\begin_layout Plain Layout

firma de consulta = B bits en cero
\end_layout

\begin_layout Plain Layout

para cada term de consulta:
\end_layout

\begin_layout Plain Layout

	para cada funcion en funcionesHash:
\end_layout

\begin_layout Plain Layout

		numero bit = funcion(term)
\end_layout

\begin_layout Plain Layout

		encender "numero bit" en la firma de consulta // puede haber colisiones
\end_layout

\begin_layout Plain Layout

para cada bit encendido en la firma de la consulta:
\end_layout

\begin_layout Plain Layout

	chequear el registro n "bit encendido" del archivo indice
\end_layout

\begin_layout Plain Layout

	documentos candidatos += documentos que tienen 1 en el registro
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

resultados = revisar(documentos candidatos) // descarto docs que tengan
 falsos positivos
\end_layout

\begin_layout Plain Layout

devolver resultados
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Consultar mediante índices de porciones de firmas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="7cm">
<column alignment="center" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparado con índice de firma: solo hay que leer 
\begin_inset Formula $FN$
\end_inset

 registros, donde 
\begin_inset Formula $N$
\end_inset

 es la cantidad de términos de la consulta y 
\begin_inset Formula $F$
\end_inset

 la cantidad de funciones de hash.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Bitmaps
\series default
: cada registro 
\begin_inset Formula $i$
\end_inset

 del archivo índice (secuencial) representa un término 
\begin_inset Formula $i$
\end_inset

.
 Cada registro tiene tantos bits como documentos halla (
\begin_inset Formula $j$
\end_inset

):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
p(t_{i},d_{j})=\begin{cases}
1 & \mbox{si }t_{i}\in d_{j}\\
0 & \mbox{si }t_{i}\not\in d_{j}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

N = cantidad de docs
\end_layout

\begin_layout Plain Layout

para cada doc en coleccion:
\end_layout

\begin_layout Plain Layout

	para cada term en doc:
\end_layout

\begin_layout Plain Layout

		si no esta en vocabulario:
\end_layout

\begin_layout Plain Layout

			agregar <term, id term> a vocabulario
\end_layout

\begin_layout Plain Layout

		si esta:
\end_layout

\begin_layout Plain Layout

			obtener su id term de vocabulario
\end_layout

\begin_layout Plain Layout

		agregar <id term, id doc> a archivo temporal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar archivo temporal por "id term + id doc"
\end_layout

\begin_layout Plain Layout

para cada id term en archivo temporal:
\end_layout

\begin_layout Plain Layout

	firma term = N bits en 0
\end_layout

\begin_layout Plain Layout

	para cada id doc:
\end_layout

\begin_layout Plain Layout

		encender bit "id doc " de firma term
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	agregar firma term a bitmap
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexación con bitmaps.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

candidatos = {}
\end_layout

\begin_layout Plain Layout

para cada term en consulta:
\end_layout

\begin_layout Plain Layout

	obtener su id term de vocabulario
\end_layout

\begin_layout Plain Layout

	docs = obtener registro "id term" del bitmap
\end_layout

\begin_layout Plain Layout

	candidatos += docs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

revisar candidatos para descartar falsos positivos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Consultas con bitmaps.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No produce falsos positivos.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desperdicia mucho espacio (si hay
\begin_inset Formula $N$
\end_inset

 documentos y 
\begin_inset Formula $n$
\end_inset

 términos, ocupa 
\begin_inset Formula $Nn$
\end_inset

 bits).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eficiente para consultas booleanas.
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pueden armarse índices secundarios sobre él.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Los bitmaps se pueden comprimir con árboles de derivación binaria.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/arboles derivacion binaria.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Árboles de derivación binaria.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Modelo vectorial
\end_layout

\begin_layout Standard
Dados los documentos 
\begin_inset Formula $D=\{d_{1},d_{2},\ldots,d_{N}\}$
\end_inset

 (hay 
\begin_inset Formula $N$
\end_inset

 documentos) y los términos 
\begin_inset Formula $T=\{t_{1},t_{2},\ldots,t_{H}\}$
\end_inset

 (hay 
\begin_inset Formula $H$
\end_inset

 términos), cada documento 
\begin_inset Formula $d_{j}$
\end_inset

 se modela como un vector
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overrightarrow{d_{j}}=\left[p\left(t_{1},d_{j}\right),p\left(t_{2},d_{j}\right),\ldots,p\left(t_{H},d_{j}\right)\right]
\]

\end_inset


\end_layout

\begin_layout Standard
donde 
\begin_inset Formula $p\left(t_{i},d_{j}\right)$
\end_inset

 es el peso del término 
\begin_inset Formula $i$
\end_inset

 en el documento 
\begin_inset Formula $j$
\end_inset

.
 Hay varias formas para representar estos pesos, una de ellas es:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p\left(t_{i},d_{j}\right)=\underset{\mbox{peso local}}{\underbrace{ft_{ij}}}\cdot\underset{\mbox{peso global}}{\underbrace{\log_{10}\left(\frac{N}{n_{i}}\right)}}
\]

\end_inset


\end_layout

\begin_layout Standard
donde: 
\end_layout

\begin_layout Itemize
\noindent
\align left
\begin_inset Formula $ft_{ij}=$
\end_inset

 frecuencia del término 
\begin_inset Formula $i$
\end_inset

 en el documento 
\begin_inset Formula $j$
\end_inset

 (si aumenta 
\begin_inset Formula $ft_{ij}$
\end_inset

, aumenta 
\begin_inset Formula $p\left(t_{i},d_{j}\right)$
\end_inset

) 
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{i}=$
\end_inset

 cantidad de documentos en los que aparece el término 
\begin_inset Formula $i$
\end_inset

 (si aumenta 
\begin_inset Formula $n_{i}$
\end_inset

, disminuye 
\begin_inset Formula $p\left(t_{i},d_{j}\right)$
\end_inset

).
 
\end_layout

\begin_layout Standard

\bar under
Forma de implementación
\bar default
: 
\end_layout

\begin_layout Itemize

\series bold
Listas invertidas
\series default
.
 Formadas por dos estructuras:
\end_layout

\begin_deeper
\begin_layout Enumerate
Vocabulario: Estructura de búsqueda.
 Suele ser un árbol 
\begin_inset Formula $B$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
<\mbox{i(termino),peso global, \ensuremath{ft}, offset lista invertida}>
\]

\end_inset


\end_layout

\begin_layout Standard
La frecuencia de cada término se almacena aquí para resolver las consultas
 más eficientemente (sin tener que acceder a sus listas invertidas), del
 término más a menos frecuente.
\end_layout

\end_deeper
\begin_layout Enumerate
Entradas de listas invertidas, una por cada término: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
<doc_{1},\gamma\left(\frac{freq_{t,d_{1}}}{\left|\overrightarrow{doc_{1}}\right|}\right);\ldots;doc_{ft},\gamma\left(\frac{freq_{t,d_{ft}}}{\left|\overrightarrow{doc_{ft}}\right|}\right)>
\]

\end_inset


\end_layout

\begin_layout Enumerate
Si la colección de documentos es muy grande, en orden 
\series bold
decreciente
\series default
 de frecuencia 
\series bold
normalizada
\series default
.
\end_layout

\begin_layout Enumerate
Si la colección de documentos es chica, en orden 
\series bold
creciente
\series default
 de documento.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Modelo probabilístico
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Sim\left(d,q\right)=\frac{P\left(d\mbox{ es relevante para la consulta }q\right)}{P\left(d\mbox{ no es relevante para la consulta }q\right)}
\]

\end_inset


\end_layout

\begin_layout Section
Consultas
\end_layout

\begin_layout Standard
Hay dos tipos:
\end_layout

\begin_layout Itemize

\series bold
Booleanas
\series default
: la consulta es una lista de términos combinados con conectivas AND (+),
 OR, NOT (-).
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Relevancia
\bar default
: binaria.
 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 es relevante, 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

 no lo es.
 Un documento es relevante para un término sí y sólo sí contiene a ese término.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy usado por expertos.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pequeñas variaciones en la consulta producen resultados muy distintos.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No discrimina entre documentos más o menos relevantes.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No tiene en cuenta la frecuencia de aparición de las palabras.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No considera 
\emph on
matchs 
\emph default
parciales.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No permite ordenar los resultados.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El usuario promedio no entiende reglas lógicas.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Usar ANDs produce mucha precisión pero bajo recall.
 Usar ORs produce mucho recall pero baja precisión.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Rankeadas
\series default
: la consulta es una lista de términos.
 Se aplica una heurística para decidir la similitud entre cada documento
 con la consulta.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mayor precisión que con consultas booleanas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se requiere más información que para resolver consultas booleanas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requiere mayor procesamiento que para resolver consultas booleanas
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Booleanas
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

consulta(q):
\end_layout

\begin_layout Plain Layout

	para cada term de q:
\end_layout

\begin_layout Plain Layout

		obtener del arbol B# su frecuencia y la direccion en disco de su lista
 invertida
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	identificar el term de q con la menor frecuencia
\end_layout

\begin_layout Plain Layout

	leer la lista invertida del termino con la menor frecuencia
\end_layout

\begin_layout Plain Layout

	C = {lista invertida del termino con la menor frecuencia}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	para cada term restante de q:
\end_layout

\begin_layout Plain Layout

		leer su correspondiente lista invertida
\end_layout

\begin_layout Plain Layout

		para cada "num doc" en C:
\end_layout

\begin_layout Plain Layout

			si ("num doc" no esta en la lista invertida de term):
\end_layout

\begin_layout Plain Layout

				C = C - {"num doc"}
\end_layout

\begin_layout Plain Layout

		si (|C| = 0):
\end_layout

\begin_layout Plain Layout

			devolver no hay resultados
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	para cada "num doc" en C:
\end_layout

\begin_layout Plain Layout

		devolver doc correspondiente
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Consultas 
\series bold
conjuntivas
\series default
 en el modelo booleano.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
La consulta debe ser modificada con las leyes de De Morgan para llevarla
 a la forma normal disyuntiva.
\end_layout

\begin_layout Itemize
Se realizan las operaciones de conjuntos correspondientes sobre las listas
 invertidas.
 Como estas están ordenadas, se puede operar recorriéndolas secuencialmente.
 Si una lista es corta y la otra larga, puede buscarse binariamente los
 elementos de la lista corta en la lista larga.
 
\end_layout

\begin_layout Itemize
Si las listas estuvieran codificadas con 
\begin_inset Formula $d-gaps$
\end_inset

, se ahorra espacio pero no se puede realizar la búsqueda binaria, y conviene
 almacenar, cada tanto, un valor absoluto.
 
\end_layout

\begin_layout Itemize
Costo de procesar la consulta 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\[
O\left(\sum_{\forall t\in q}f_{t}\right)
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Si las listas se codifican con 
\begin_inset Formula $d-gaps$
\end_inset

, el orden es el mismo pero la constante es mayor.
\end_layout

\end_deeper
\begin_layout Itemize
Ventaja: para una consulta conjuntiva, la cantidad de documentos resultado
 siempre es menor o igual que la frecuencia del término de la consulta menos
 frecuente.
\end_layout

\begin_layout Subsection
Rankeadas
\end_layout

\begin_layout Standard
A diferencia del modelo booleano, en este modelo, agregar un término a la
 consulta agranda la búsqueda en vez de achicarla.
\end_layout

\begin_layout Standard
En las consultas de este modelo, los documentos devueltos podrían no contener
 a todos los términos de la consulta (pero deben contener al menos uno).
 Se necesita devolver, por ejemplo, los 100 documentos más similares a la
 consulta, y luego seleccionar los más relevantes, en lo que se conoce como
 el 
\series bold
proceso de ranking
\series default
.
\end_layout

\begin_layout Subsubsection
Coordinate matching
\end_layout

\begin_layout Standard
Para cada documento, se cuenta la cantidad de términos de la consulta que
 posee.
 Muestra primero los documentos que tienen más términos de la consulta.
\end_layout

\begin_layout Standard
Representa a cada documento 
\begin_inset Formula $d$
\end_inset

 y consulta como un vector 
\begin_inset Formula $v$
\end_inset

 de 
\begin_inset Formula $H$
\end_inset

 componentes.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v_{i}=\begin{cases}
1 & \mbox{si }t_{i}\in d\\
0 & \mbox{si }t_{i}\not\in d
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

vector consulta = (0,0,0,...,0) // vector de longitud H
\end_layout

\begin_layout Plain Layout

vector consulta [termino] = frecuencia termino en consulta
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada documento en coleccion:
\end_layout

\begin_layout Plain Layout

	vector documento = (0,0,0,...,0) // vector de longitud H
\end_layout

\begin_layout Plain Layout

	para cada termino en documento:
\end_layout

\begin_layout Plain Layout

		vector documento [termino] = frecuencia termino en documento
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada documento en coleccion:
\end_layout

\begin_layout Plain Layout

	ranking documento = vector consulta x vector documento // producto interno
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar los rankings en orden descendente
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolución de consulta con coordinate matching.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No tiene en cuenta la frecuencia de los términos en los documentos
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Asume que todos los términos tienen igual importancia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Favorece a los documentos más largos porque tienen más términos
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Producto interno
\end_layout

\begin_layout Standard
Representa a cada documento 
\begin_inset Formula $d$
\end_inset

 y consulta como un vector 
\begin_inset Formula $v$
\end_inset

 de 
\begin_inset Formula $H$
\end_inset

 componentes.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v_{i}=freq_{i,d}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Asume que todos los términos tienen igual importancia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Favorece a los documentos más largos porque tienen más términos
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Producto interno mejorado
\end_layout

\begin_layout Standard
Reconoce que cada término tiene una importancia determinada.
 
\begin_inset Formula 
\[
I_{t}=\log_{10}\left(\frac{N}{ft}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Representa a cada documento con un vector 
\begin_inset Formula $v$
\end_inset

 de 
\begin_inset Formula $H$
\end_inset

 componentes.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v_{i}=\mbox{frecuencia termino i en documento}\times I_{t}
\]

\end_inset


\end_layout

\begin_layout Standard
Representa a cada consulta con un vector 
\begin_inset Formula $c$
\end_inset

 de 
\begin_inset Formula $H$
\end_inset

 componentes.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
c_{i}=\mbox{frecuencia termino i en consulta}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

para cada documento en coleccion:
\end_layout

\begin_layout Plain Layout

	ranking documento = v x c // producto interno
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar los rankings en orden descendente
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolución de consulta con producto interno mejorado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reconoce que cada término tiene una importancia determinada.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Favorece a los documentos más largos porque tienen más términos.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Distancia coseno
\end_layout

\begin_layout Standard
Representa a cada documento y consulta como un vector 
\begin_inset Formula $v$
\end_inset

 de 
\begin_inset Formula $H$
\end_inset

 componentes.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
v_{i} & = & \left[p\left(t_{1},d\right),\ldots,p\left(t_{H},d\right)\right]\\
p\left(t_{i},d\right) & \underset{\mbox{norma euclídea}}{=} & ft_{i,d}\times\log_{10}\frac{N}{n_{i}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
El vector de la consulta tiene en cuenta los pesos de cada término.
\end_layout

\begin_layout Standard
La 
\series bold
similitud
\series default
 entre dos documentos 
\begin_inset Formula $d_{i}$
\end_inset

 y 
\begin_inset Formula $d_{j}$
\end_inset

 se calcula mediante la 
\series bold
distancia coseno
\series default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\series bold
Teorema: 
\begin_inset Formula $\mbox{similitud}=\cos\theta=\frac{X\cdot Y}{\left\Vert X\right\Vert \cdot\left\Vert Y\right\Vert }$
\end_inset

.
 
\series default
Geométricamente, 
\begin_inset Formula $\theta$
\end_inset

 es el ángulo entre los vectores 
\begin_inset Formula $X$
\end_inset

 e 
\begin_inset Formula $Y$
\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula 
\begin{eqnarray*}
sim(d_{i},d_{j})=\frac{\overrightarrow{d_{_{i}}}\times\overrightarrow{d_{j}}}{\left|\overrightarrow{d_{_{i}}}\right|\times\left|\overrightarrow{d_{j}}\right|} & \underset{\mbox{norma euclídea}}{=} & \frac{\sum_{t}p\left(t,d_{i}\right)\times p\left(t,d_{j}\right)}{\sqrt{\sum_{t}p\left(t,d_{i}\right)^{2}}\times\sqrt{\sum_{t}p\left(t,d_{j}\right)^{2}}}\\
 & \underset{\mbox{norma infinito}}{=} & \frac{\sum_{t}p\left(t,d_{i}\right)\times p\left(t,d_{j}\right)}{\mbox{max freq}_{d_{i}}\times\mbox{max freq}_{d_{j}}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Si se usa la norma euclídea, esta similitud es un valor entre 0 y 1.
 Si los documentos son iguales, tienen similitud 1, y si no comparten términos,
 la similitud es 0.
\end_layout

\begin_layout Standard
Para calcular la similitud entre una consulta 
\begin_inset Formula $q$
\end_inset

 y un documento 
\begin_inset Formula $d$
\end_inset

, se transforma la consulta en un vector con 
\begin_inset Formula $H$
\end_inset

 componentes.
 Para resolver más rápidamente la consulta, se pueden realizar dos aproximacione
s:
\end_layout

\begin_layout Itemize
Las consultas poseen términos distintos (con lo cual 
\begin_inset Formula $ft_{q}\approx1$
\end_inset

 para todo 
\begin_inset Formula $t$
\end_inset

), 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\overrightarrow{q}\right|$
\end_inset

 es constante para cualquier consulta (afecta el valor de la similitud pero
 no el orden del ranking)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
sim\left(q,d\right) & \approx & \sum_{t\in q}\underset{\mbox{peso local}}{\underbrace{\frac{ft_{i,d}}{\left|\overrightarrow{d}\right|}}}\cdot\underset{\mbox{peso global}}{\underbrace{\log_{10}\left(\frac{N}{n_{i}}\right)}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\overrightarrow{d}\right|=$
\end_inset

 norma del vector.
 Es el peso del documento en toda la colección.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\frac{ft_{ij}}{\left|\overrightarrow{d_{j}}\right|}=$
\end_inset

 frecuencia normalizada del término 
\begin_inset Formula $i$
\end_inset

 en el documento 
\begin_inset Formula $j$
\end_inset

.
 Este valor se debe almacenar en el índice para evitar tener que hacer el
 cálculo en cada consulta.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $p(t_{i},d_{j})=ft_{i,j}\cdot\log_{10}\left(\frac{N}{n_{i}}\right)=$
\end_inset

 peso del término 
\begin_inset Formula $i$
\end_inset

 en el documento 
\begin_inset Formula $j$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $ft_{i,j}$
\end_inset

 es la frecuencia del término 
\begin_inset Formula $i$
\end_inset

 en la el documento 
\begin_inset Formula $j$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reconoce que cada término tiene una importancia determinada.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al incorporar en el cálculo 
\begin_inset Formula $\left|\overrightarrow{d}\right|$
\end_inset

, no favorece a los documentos más largos.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	// la lista invertida de un termino esta formada por <cantidad docs, (num
 doc, freq norm) +>
\end_layout

\begin_layout Plain Layout

	// la lista invertida esta ordenada por "num doc" creciente
\end_layout

\begin_layout Plain Layout

	para cada doc en coleccion:
\end_layout

\begin_layout Plain Layout

		acumulador[doc]= 0
\end_layout

\begin_layout Plain Layout

	para cada term en consulta:
\end_layout

\begin_layout Plain Layout

		recuperar lista de invertida para "term"
\end_layout

\begin_layout Plain Layout

		para cada entrada de la lista invertida <doc, freq norm>:
\end_layout

\begin_layout Plain Layout

			acumulador[doc] += peso global term * freq norm
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ordenar los acumuladores en forma decreciente
\end_layout

\begin_layout Plain Layout

	devolverlos en ese orden
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cálculo de ranking en el modelo vectorial para colecciones chicas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	// la lista invertida de un termino esta formada por <long, (num doc, freq
 norm) +>
\end_layout

\begin_layout Plain Layout

	// la lista invertida esta ordenada por "freq norm" decreciente
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	para cada term en consulta:
\end_layout

\begin_layout Plain Layout

		leer su lista invertida
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ordenar las listas invertidas por "peso global" decreciente
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	para cada lista invertida:
\end_layout

\begin_layout Plain Layout

		pivote lista = primer doc lista
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	contador resultados = 0
\end_layout

\begin_layout Plain Layout

	mientras (contador resultados < k)
\end_layout

\begin_layout Plain Layout

		para cada lista invertida:
\end_layout

\begin_layout Plain Layout

			sim (pivote lista, term) = peso global term * freq norm doc
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		devolver doc pivote con mayor valor de "sim"
\end_layout

\begin_layout Plain Layout

		en la lista que tenia el pivote que acabamos de devolver:
\end_layout

\begin_layout Plain Layout

			avanzar en 1 el pivote
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		contador resultados ++
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cálculo de ranking en el modelo vectorial para colecciones grandes (devuelve
 
\begin_inset Formula $k$
\end_inset

 resultados)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Retroalimentación en el modelo vectorial
\end_layout

\begin_layout Standard
Puede preguntársele al usuario cuáles documentos recuperados son relevantes
 y cuáles no, y volver a pesar todo en función de la respuesta.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $V$
\end_inset

 el conjunto de documentos recuperados para una consulta.
 El usuario los clasifica en 
\begin_inset Formula $V_{r}$
\end_inset

 (resultados relevantes) y 
\begin_inset Formula $V_{nr}$
\end_inset

 (resultados no relevantes).
 La fórmula de Rochio modifica el vector de la consulta de la siguiente
 manera:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overrightarrow{c}_{m}=\alpha\overrightarrow{c}+\frac{\beta}{\left|V_{r}\right|}\left(\sum_{d_{i}\in V_{r}}\overrightarrow{d_{i}}\right)-\frac{\gamma}{\left|V_{nr}\right|}\left(\sum_{d_{i}\in V_{nr}}\overrightarrow{d_{i}}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Para no tener que pedirle al usuario los documentos no relevantes, puede
 asumirse que 
\begin_inset Formula $\gamma=0$
\end_inset

.
\end_layout

\begin_layout Section

\series bold
Consultas e
\series default
speciales
\end_layout

\begin_layout Subsection

\series bold
Consultas de frases
\end_layout

\begin_layout Standard
Por ejemplo: 
\begin_inset Quotes eld
\end_inset

Segunda Guerra Mundial
\begin_inset Quotes erd
\end_inset

.
 La distancia entre los términos debe ser exactamente la indicada en la
 frase.
 Si hay un documento que posee todos los términos, hay que, además, conocer
 la posición relativa de cada término en el documento.
\end_layout

\begin_layout Standard
Hay dos formas de resolver estas consultas:
\end_layout

\begin_layout Itemize

\series bold
Índice invertido booleano posicional
\series default
: con tres estructuras:
\end_layout

\begin_deeper
\begin_layout Itemize
Vocabulario: 
\begin_inset Formula 
\[
<\mbox{i(termino),id termino, cantidad docs, offset lista invertida}>
\]

\end_inset


\end_layout

\begin_layout Itemize
Listas de documentos: para un término, se almacenan 
\begin_inset Quotes eld
\end_inset

cantidad docs
\begin_inset Quotes erd
\end_inset

 registros del siguiente formato: 
\begin_inset Formula 
\[
<id\, doc\mbox{, freq termino en \ensuremath{doc}, offset lista posiciones \ensuremath{doc}}>
\]

\end_inset


\end_layout

\begin_layout Itemize
Listas de posiciones: para un término y un documento, se almacena el siguiente
 registro: 
\begin_inset Formula 
\[
<p_{1},p_{2},\ldots,p_{\mbox{freq termino en doc}}>
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\emph on
Biword index
\series default
\emph default
: los términos se indexan de a pares.
 Para cada 
\emph on
firstword 
\emph default
hay una lista de 
\emph on
nextwords
\emph default
 que lo siguen, los documentos y la posición del par en ese documento.
\end_layout

\begin_deeper
\begin_layout Standard
Si se combina un 
\emph on
biword index
\emph default
 para términos comunes con un índice invertido para términos raros, se reduce
 a la mitad el tiempo de resolución de una consulta, con un 
\emph on
space overhead
\emph default
 del 10% del índice invertido.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/biword index.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Biword index.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/biword index and inverted index.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Biword index con índice invertido.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Biword index.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
La resolución de una consulta se resuelve descomponiendo la misma en pares
 de términos.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resolver consulta (c):
\end_layout

\begin_layout Plain Layout

	ordenar los terminos de c de mas raros a mas comunes, guardando sus posiciones
 originales en c
\end_layout

\begin_layout Plain Layout

	buscar la lista invertida del termino mas raro, y guardarla temporalmente.
\end_layout

\begin_layout Plain Layout

	para cada termino restante de c:
\end_layout

\begin_layout Plain Layout

		buscar su lista invertida
\end_layout

\begin_layout Plain Layout

		hacer merge con la lista temporal
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\series bold
Consultas de términos próximos / cercanos
\end_layout

\begin_layout Standard
Por ejemplo: 
\begin_inset Quotes eld
\end_inset

algoritmos árboles ~4
\begin_inset Quotes erd
\end_inset

.
 Si hay un documento que posee todos los términos, hay que, además, conocer
 la posición relativa de cada término en el documento.
\end_layout

\begin_layout Standard
La distancia entre los términos no debe superar la distancia dada.
\end_layout

\begin_layout Standard
Para reducir el espacio ocupado por el índice, se puede tener un índice
 de 
\series bold
bloques
\series default
: se almacena el bloque donde ocurre cada término.
\end_layout

\begin_layout Subsection

\series bold
Consultas con 
\series default
\emph on
wildcards
\end_layout

\begin_layout Standard
Ejemplos: 
\begin_inset Quotes eld
\end_inset

cas*
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

am?r
\begin_inset Quotes erd
\end_inset

.
 El 
\emph on
wildcard
\emph default
 * significa 
\begin_inset Quotes eld
\end_inset

uno o más caracteres desconocidos
\begin_inset Quotes erd
\end_inset

.
 El 
\emph on
wildcard 
\emph default
? significa 
\begin_inset Quotes eld
\end_inset

un caracter desconocido
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Métodos de resolución:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Fuerza bruta
\series default
: recorrer el léxico secuencialmente.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No se requieren estructuras adicionales.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Es muy lento si los wildcards aparecen al principio.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No se requiere que el léxico esté ordenado.
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No permite búsquedas de tipo 
\begin_inset Quotes eld
\end_inset

*x".
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Índice secundario de léxico rotado
\series default
: para cada término del léxico se almacenan todas sus rotaciones.
 Por ejemplo: 
\emph on
frozen
\emph default
 se convierte en 
\emph on
frozen|, rozen|f, ozen|fr, zen|fro, en|froz, n|froze, |frozen
\emph default
 (el caracter 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 indica el comienzo del término).
 Para buscar 
\emph on
fro* 
\emph default
se buscan los términos correspondientes a todas las rotaciones que comiencen
 con 
\emph on
|fro
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
Cada rotación apunta a un solo elemento del índice invertido de términos,
 porque cada rotación pertenece a un sólo término.
 El término al que refiere la rotación se obtiene rotando la rotación hasta
 llevar el 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 a un extremo, para luego quitarlo.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

para cada termino distinto:
\end_layout

\begin_layout Plain Layout

	obtener sus rotaciones
\end_layout

\begin_layout Plain Layout

	para cada rotacion:
\end_layout

\begin_layout Plain Layout

		agregar <i(rotacion)> a archivo de lexico rotado (arbol B)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexación con léxico rotado.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

si hay un solo wildcard:
\end_layout

\begin_layout Plain Layout

	rotar consulta y llevar el wildcard al extremo derecho
\end_layout

\begin_layout Plain Layout

	candidatos = buscar todos los lexicos rotados que comiencen igual, y devolver
 el termino asociado
\end_layout

\begin_layout Plain Layout

	hacer OR de candidatos
\end_layout

\begin_layout Plain Layout

	buscar documentos que tienen los candidatos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

si hay mas de un wildcard:
\end_layout

\begin_layout Plain Layout

	rotar consulta y llevar un wildcard al extremo derecho
\end_layout

\begin_layout Plain Layout

	1era opcion:
\end_layout

\begin_layout Plain Layout

		candidatos = buscar todos los lexicos rotados que comiencen igual, hasta
 el primer wildcard
\end_layout

\begin_layout Plain Layout

	2da opcion:
\end_layout

\begin_layout Plain Layout

		separar el termino en tantas partes como wildcards haya
\end_layout

\begin_layout Plain Layout

		candidatos = buscar los lexicos rotados de cada parte
\end_layout

\begin_layout Plain Layout

		devolver AND de candidatos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolución de consultas con léxico rotado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="7cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Permite resolver consultas de tipo 
\begin_inset Quotes eld
\end_inset

*x
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

x*
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

*x*
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

x*y
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El léxico rotado debe estar ordenado.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se pueden realizar búsquedas binarias sobre el léxico rotado.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se requiere un índice secundario que ocupa espacio (un término de 
\begin_inset Formula $n$
\end_inset

 caracteres aporta 
\begin_inset Formula $n+1$
\end_inset

 rotaciones).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Índice secundario de n-gramas
\series default
: es un índice invertido de n-gramas.
 Para cada término del léxico se almacenan todos sus n-gramas, para cada
 n-grama se guarda la lista de punteros a términos que tienen ese n-grama.
 Por ejemplo: 
\emph on
frozen
\emph default
 contiene los 2-gramas 
\emph on
fr, ro, oz, ze, en
\emph default
.
 Para reducir los falsos positivos en los resultados, también puede guardarse
 el caracter de fin de término: 
\emph on
|f, fr, ro, oz, ze, en, n|
\emph default
, aunque esta técnica no sirve para 1-gramas.
\end_layout

\begin_deeper
\begin_layout Standard
Para buscar el patrón 
\emph on
fro* 
\emph default
se buscan las listas de términos correspondientes a los digramas 
\emph on
|f, fr, ro
\emph default
 y se hace la intersección de las listas.
\end_layout

\begin_layout Standard
Cuanto más grande es 
\begin_inset Formula $n$
\end_inset

, más tamaño ocupa el índice secundario, pero las consultas devuelven menos
 falsos positivos.
 Si 
\begin_inset Formula $n$
\end_inset

 es chico, hay muchos más falsos positivos y hay un alto costo de procesamiento.
\end_layout

\begin_layout Standard
¿Por qué se producen falsos positivos? Ejemplo: si la consulta es 
\series bold
ten*
\series default
, se descompone en 
\series bold
te
\series default
 y 
\series bold
en
\series default
, y eso puede devolver como resultado 
\series bold
tense
\series default
 (resultado OK) y 
\series bold
enter
\series default
 (falso positivo, contiene los digramas 
\series bold
te 
\series default
y 
\series bold
en
\series default
 pero no en forma consecutiva).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

archivo temporal = {} // secuencial
\end_layout

\begin_layout Plain Layout

archivo listas de terminos = {} // secuencial
\end_layout

\begin_layout Plain Layout

archivo de n-gramas = {} // arbol B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada documento en coleccion:
\end_layout

\begin_layout Plain Layout

	para cada termino en documento:
\end_layout

\begin_layout Plain Layout

		si termino NO esta en vocabulario:
\end_layout

\begin_layout Plain Layout

			agregarlo y obtener su id termino
\end_layout

\begin_layout Plain Layout

			descomponer termino en sus n-gramas
\end_layout

\begin_layout Plain Layout

			para cada n-grama:
\end_layout

\begin_layout Plain Layout

				agregar <n-grama, id termino> a archivo temporal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ordenar archivo temporal por "n-grama + id termino"
\end_layout

\begin_layout Plain Layout

para cada n-grama:
\end_layout

\begin_layout Plain Layout

	offset = agregar lista de id_terminos a "archivo listas de terminos"
\end_layout

\begin_layout Plain Layout

	agregar <n-grama, offset> a "archivo de n-gramas"
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexación con n-gramas.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

separar consulta en sus n-gramas
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada n-grama de consulta:
\end_layout

\begin_layout Plain Layout

	terminos candidatos (n-grama) = buscar cada n-grama en índice y devolver
 sus terminos asociados
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

hacer AND de todos los terminos candidatos
\end_layout

\begin_layout Plain Layout

candidatos = verificar cada termino candidato por falsos positivos contra
 la consulta
\end_layout

\begin_layout Plain Layout

devolver OR de candidatos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolución de consultas con n-gramas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/indice-n-gramas.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Índice de n-gramas en memoria.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si el léxico está desordenado (para colecciones dinámicas), se pueden aplicar
 algunas optimizaciones: 
\end_layout

\begin_layout Enumerate

\series bold
Thresholding
\series default
: usar un valor límite fijo.
 Cuando la cantidad de candidatos a una consulta cae por debajo de este
 valor, directamente se accede a los documentos para eliminar falsos positivos.
 
\end_layout

\begin_layout Enumerate

\series bold
Blocking
\series default
: ablocar el léxico.
 La ventaja es que disminuye el tamaño del índice secundario, por dos motivos:
 algunos n-gramas aparecerán varias veces en un bloque, pero solo se necesita
 una referencia, y los valores de los punteros serán menores y podrán ser
 representados en menos bits.
 Cuanto más grandes son los bloques, menos tamaño requiere el índice, pero
 se necesita más tiempo para acceder al léxico.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/indice-n-gramas-ablocado.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Índice de n-gramas en memoria.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si el léxico está ordenado (para colecciones estáticas), se pueden aplicar
 algunas optimizaciones: 
\end_layout

\begin_layout Enumerate
Comprimir el índice secundario mediante 
\emph on
run-length encoding.

\emph default
 
\end_layout

\begin_layout Enumerate
Ablocar el índice secundario.
 
\end_layout

\begin_layout Enumerate
Usar 
\emph on
front coding
\emph default
.
 
\end_layout

\begin_layout Enumerate
Usar búsquedas binarias.
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ocupa menos espacio que un índice de léxico rotado.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pueden haber falsos positivos.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Subsection

\series bold
Consultas de términos parecidos
\end_layout

\begin_layout Standard
Por ejemplo: 
\begin_inset Quotes eld
\end_inset

~Swarzeneger
\begin_inset Quotes erd
\end_inset

.
 Se utiliza, por ejemplo, cuando no se está seguro de cómo se escribe el
 término.
 
\end_layout

\begin_layout Standard

\series bold
Distancia de Levenshtein
\series default
: métrica para medir la diferencia entre dos cadenas de texto.
 La distancia entre dos 
\emph on
strings
\emph default
 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 es la cantidad mínima de ediciones de un caracter (inserciones, supresiones
 y sustituciones) necesarias para cambiar de una palabra a la otra.
\end_layout

\begin_layout Standard
Para reducir el cálculo de distancias en la resolución de consultas, se
 utilizan 
\series bold
índices de espacios métricos
\series default
.
 Estos calculan muchas distancias al momento de construir el índice.
\end_layout

\begin_layout Standard
Un espacio métrico se define como el par 
\begin_inset Formula $(U,d)$
\end_inset

.
 
\series bold

\begin_inset Formula $U$
\end_inset

 
\series default
es el universo de objetos, y 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
 es una función de distancia tal que
\end_layout

\begin_layout Itemize
\begin_inset Formula $d(x,y)\geq0$
\end_inset

 para todo 
\begin_inset Formula $(x,y)\in U$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $d(x,x)=0$
\end_inset

 para todo 
\begin_inset Formula $x\in U$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $d(x,y)=d(y,x)$
\end_inset

 para todo 
\begin_inset Formula $(x,y)\in U$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $d(x,y)\leq d(x,z)+d(z,y)$
\end_inset

 para todo 
\begin_inset Formula $(x,y,z)\in U$
\end_inset

 (
\series bold
desigualdad triangular
\series default
).
\end_layout

\begin_layout Standard

\bar under
Objetivo
\bar default
: dada una consulta 
\begin_inset Formula $q\in U$
\end_inset

, se pueden querer dos cosas.
\end_layout

\begin_layout Enumerate
Los objetos (términos) de 
\begin_inset Formula $U$
\end_inset

 que estén, como máximo, a una distancia 
\begin_inset Formula $r$
\end_inset

 de 
\begin_inset Formula $q$
\end_inset

.
 Existen dos formas de resolver esta consulta.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	pivotes = {}
\end_layout

\begin_layout Plain Layout

	M = maxima longitud de termino en el vocabulario
\end_layout

\begin_layout Plain Layout

	pivotes += {primer termino del vocabulario}
\end_layout

\begin_layout Plain Layout

	para cada termino en vocabulario:
\end_layout

\begin_layout Plain Layout

		si para cada pivote se cumple (d(termino, pivote) >= coef * M ): //coef
 entre 0.4 y 0.6
\end_layout

\begin_layout Plain Layout

			pivotes += {termino}
\end_layout

\begin_layout Plain Layout

	devolver pivotes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo de selección de pivotes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Mediante 
\series bold
clusters
\series default
 de objetos: para cada cluster, se le asocian términos y un radio.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\mbox{(Cluster}\left(\mbox{pivote,radio,(termino, d(termino,pivote)+)}\right)+)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

para cada termino:
\end_layout

\begin_layout Plain Layout

	para cada pivote:
\end_layout

\begin_layout Plain Layout

		calcular d(termino,pivote)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada termino:
\end_layout

\begin_layout Plain Layout

	cluster asignado = min(pivote : d(termino, pivote)) // politicas de desempate?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada cluster:
\end_layout

\begin_layout Plain Layout

	radio = max (d(termino,pivote))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexar mediante clusters de objetos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

C = {}
\end_layout

\begin_layout Plain Layout

para cada cluster:
\end_layout

\begin_layout Plain Layout

	si ( d(q,pivote ) > r + radio):
\end_layout

\begin_layout Plain Layout

		continuar // Descartamos clusters cuyo radio no interseque con el radio
 de consulta
\end_layout

\begin_layout Plain Layout

	si no:
\end_layout

\begin_layout Plain Layout

		para cada term en cluster:
\end_layout

\begin_layout Plain Layout

			si ( |d(q,pivote) - d(term,pivote)| > r):
\end_layout

\begin_layout Plain Layout

				continuar // Descartar terminos que no esten en el radio de la consulta
\end_layout

\begin_layout Plain Layout

			si no:
\end_layout

\begin_layout Plain Layout

				si (d(q,term) <= r)
\end_layout

\begin_layout Plain Layout

					C = C + {term}
\end_layout

\begin_layout Plain Layout

devolver C
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolver consultas mediante clusters de objetos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Mediante 
\series bold
SSS
\series default
 (
\emph on
Sparse Spatial Selection
\emph default
): se eligen algunos términos pivotes, y para cada término y para cada pivote,
 se almacena la distancia del término al pivote.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\mbox{SSS(Firma(d(termino,pivote1),..,d(termino,pivoteK))+)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

para cada termino:
\end_layout

\begin_layout Plain Layout

	para cada pivote:
\end_layout

\begin_layout Plain Layout

		guardar d(termino,pivote)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Indexar mediante SSS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

C = {}
\end_layout

\begin_layout Plain Layout

para cada pivote:
\end_layout

\begin_layout Plain Layout

	calcular d(q,pivote)
\end_layout

\begin_layout Plain Layout

para cada termino de vocab:
\end_layout

\begin_layout Plain Layout

	si para algun pivote se cumple ( |d(q,pivote) - d(termino, pivote)| > r):
\end_layout

\begin_layout Plain Layout

		continue // Siguiente termino
\end_layout

\begin_layout Plain Layout

	si no:
\end_layout

\begin_layout Plain Layout

		C = C + {termino}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R = {}
\end_layout

\begin_layout Plain Layout

para cada Candidato en C:
\end_layout

\begin_layout Plain Layout

	si ( 0 < d(q,Candidato) <= r)
\end_layout

\begin_layout Plain Layout

		R = R + {Candidato}
\end_layout

\begin_layout Plain Layout

devolver R
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolver consultas mediante SSS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Los 
\begin_inset Formula $k$
\end_inset

 objetos de 
\begin_inset Formula $U$
\end_inset

 que estén más cercanos a 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
Mediante 
\series bold
árboles de aproximación espacial 
\series default
(
\begin_inset Formula $K-NN$
\end_inset

).
\end_layout

\end_deeper
\begin_layout Section
Evaluación de un sistema de consultas
\end_layout

\begin_layout Standard
Para evaluar la efectividad de un sistema de consultas, se utilizan dos
 estadísticas acerca de los resultados devueltos ante una 
\emph on
query
\emph default
:
\end_layout

\begin_layout Standard

\series bold
Precisión
\series default
: 
\begin_inset Quotes eld
\end_inset

cuántos documentos recuperados son relevantes
\begin_inset Quotes erd
\end_inset

.
 Mide cuán cerca estamos del objetivo.
 
\begin_inset Formula 
\[
P=\frac{\mbox{\left\{  \mbox{Relevantes}\right\}  \cap\left\{  \mbox{Devueltos}\right\}  }}{\left\{ \mbox{Devueltos}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard

\bar under
Ejemplo
\bar default
: si de 50 documentos devueltos 35 son relevantes a la consulta, la precisión
 es 
\begin_inset Formula $\frac{35}{50}=70\%$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Recuperación (
\emph on
recall
\emph default
)
\series default
: 
\begin_inset Quotes eld
\end_inset

cuántos documentos relevantes se recuperaron".
 Mide el grado de exhaustividad del sistema.
 
\begin_inset Formula 
\[
R=\frac{\mbox{\left\{  \mbox{Relevantes}\right\}  \cap\left\{  \mbox{Devueltos}\right\}  }}{\left\{ \mbox{Relevantes}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard

\bar under
Ejemplo
\bar default
: si había 70 documentos relevantes a la consulta, y si se devuelven 50
 de los cuales solo 35 son relevantes, el recall es de 
\begin_inset Formula $\frac{35}{70}=50\%$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/precision-recall-2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cuando aumenta la precisión, baja el recall, y viceversa.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/precision-recall.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Precisión y recall.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Evaluación de consultas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementación
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de documentos 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de términos 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de términos distintos 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de punteros a documentos 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de espacio requerida como máximo 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f\cdot\left\lceil \log_{2}n\right\rceil $
\end_inset

 bits
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ley de Zipf
\series default
: modela la distribución de frecuencias de las palabras de un léxico.
 Unas pocas palabras (las 
\emph on
stopwords
\emph default
) aparecen muchas veces, y muchas palabras aparecen pocas veces.
\end_layout

\begin_layout Standard
La palabra más frecuente aparece el doble de veces que la segunda palabra
 más frecuente, el triple de veces que la tercera palabra más frecuente,
 etc.
\end_layout

\begin_layout Standard
Sean:
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

 términos distintos,
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

 la frecuencia,
\end_layout

\begin_layout Itemize
\begin_inset Formula $s$
\end_inset

 el valor del exponente que caracteriza la distribución
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(k;s,N)=\frac{1/k^{s}}{\sum_{n=1}^{N}(1/n^{s})}
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ley de Heaps
\series default
: el número de términos únicos 
\begin_inset Formula $V$
\end_inset

 de una colección con 
\begin_inset Formula $N$
\end_inset

 términos es aproximadamente 
\begin_inset Formula $\sqrt{N}$
\end_inset

.
 De forma más general:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
V=C\times N^{\beta}
\]

\end_inset

donde 
\begin_inset Formula $C$
\end_inset

 y 
\begin_inset Formula $\beta\in(0,1)$
\end_inset

 dependen del tipo de texto.
 En la práctica, 
\begin_inset Formula $C\in[5,50]$
\end_inset

 y 
\begin_inset Formula $\beta\in(0.4;0.6)$
\end_inset

.
 Además, 
\begin_inset Formula $V$
\end_inset

 suele ser menos del 1% de 
\begin_inset Formula $N$
\end_inset

.
 Es decir: el vocabulario entra en memoria RAM (5 MB para 1 GB de texto).
\end_layout

\begin_layout Subsection
Compresión del léxico
\end_layout

\begin_layout Standard
Transformar las palabras antes de indexarlas.
\end_layout

\begin_layout Enumerate
Usar una lista de 
\series bold
\emph on
stopwords
\series default
\emph default
, para no indexar palabras que se repiten mucho.
\end_layout

\begin_deeper
\begin_layout Standard

\bar under
Ejemplos
\bar default
: 
\begin_inset Quotes eld
\end_inset

el
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

la
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

que
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ellos
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nosotros
\begin_inset Quotes erd
\end_inset

, y frases como 
\begin_inset Quotes eld
\end_inset

sin embargo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a pesar de
\begin_inset Quotes erd
\end_inset

, etc.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El índice ocupa menos espacio.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muchas consultas incluyen 
\emph on
stopwords
\emph default
, y solo podrían resolverse analizando todos los documentos.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No tiene sentido eliminar 
\emph on
stopwords
\emph default
 si el índice invertido se almacena comprimido, porque los punteros de las
 palabras más frecuentes pueden almacenarse con muy pocos bits.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No tiene sentido eliminar 
\emph on
stopwords
\emph default
 si se usan índices de firmas o bitmaps.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Las 
\emph on
stopwords
\emph default
 se deben guardar en un archivo, y cargarlas en memoria al momento de indexar.
\end_layout

\end_deeper
\begin_layout Enumerate
Usar 
\emph on
case folding
\emph default
 y eliminar signos de puntuación, acentos, etc.
\end_layout

\begin_layout Enumerate
Usar 
\series bold
\emph on
stemming
\series default
\emph default
: guardar solo el tallo de las palabras.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aumenta el recall.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Baja la precisión.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Reducción de plural a singular: 
\begin_inset Quotes eld
\end_inset


\emph on
person#
\emph default

\begin_inset Quotes erd
\end_inset

 representa 
\begin_inset Quotes eld
\end_inset

persona
\begin_inset Quotes erd
\end_inset

 y 
\begin_inset Quotes eld
\end_inset

personas
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Reducción de género y número de adjetivos: 
\begin_inset Quotes eld
\end_inset


\emph on
buen?
\emph default

\begin_inset Quotes erd
\end_inset

 representa 
\begin_inset Quotes eld
\end_inset

buen
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

bueno
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

buena
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

buenos
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

buenas
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Sustituir palabras por sus sinónimos.
 (Luego hay que modificar la consulta también).
\end_layout

\begin_layout Standard
Métodos para almacenar el léxico ordenado:
\end_layout

\begin_layout Enumerate

\series bold
Términos de longitud fija
\series default
: se destina un espacio fijo para cada término, equivalente a la longitud
 del término más largo 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\mbox{(término: x bytes, puntero a lista invertida: 4 bytes)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Puede hacerse búsqueda binaria
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ocupa mucho espacio
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Concatenación de términos
\series default
: todos los términos se almacenan de forma contigua, y se utilizan punteros
 para acceder a ellos.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\mbox{(puntero a archivo de términos: 4 bytes, puntero a lista invertida: 4 bytes)}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Front coding
\series default
: aprovecha el hecho de que el vocabulario está ordenado alfabéticamente
 y que los comienzos se repiten.
\end_layout

\begin_deeper
\begin_layout Standard
En el léxico (hojas del árbol B#) se almacenan registros con la siguiente
 estructura:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\mbox{\# chars iguales al anterior: 1 byte, \# chars distintos al anterior : 1 byte, chars distintos, puntero a lista invertida: 4 bytes})+)
\]

\end_inset


\end_layout

\begin_layout Standard
El primer registro de cada hoja debe almacenar el término completo:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mbox{(longitud del término: 1 byte, término: longitud, puntero a lista invertida : 4 bytes)}
\]

\end_inset


\end_layout

\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
codazo, codearse, codera, codicia, codiciar, codiciosa, codicioso, codificar,
 codigo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6|codazo#|3|5|earse#|4|2|ra#|3|4|icia#|7|1|r#|6|3|osa#|8|1|o#|4|5|ficar#|4|2|go#
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
El léxico ocupa menos espacio.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
La búsqueda de un término implica descomprimir secuencialmente la hoja.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Front coding parcial o por secciones
\series default
:
\end_layout

\begin_deeper
\begin_layout Standard
En el léxico (hojas del árbol B#) se almacenan registros con la siguiente
 estructura:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\mbox{\# chars iguales al anterior, \# chars distintos al anterior, chars distintos, puntero a lista invertida})+)
\]

\end_inset


\end_layout

\begin_layout Standard
El primer registro de cada hoja, y cada 
\begin_inset Formula $n$
\end_inset

 registros (
\begin_inset Formula $n\approx\sqrt{\mbox{\# registros en hoja}}$
\end_inset

) debe almacenar el término completo:
\begin_inset Formula 
\[
\mbox{(longitud del término,término,puntero a lista invertida)}
\]

\end_inset


\end_layout

\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
codazo, codearse, codera, codicia, codiciar, codiciosa, codicioso, codificar,
 codigo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6|codazo#|3|5|earse#|4|2|ra#|<p1>|7|codicia#|7|1|r#|6|3|osa#|<p2>|9|codicioso#|4
|5|ficar#|4|2|go#|<p3>|9|3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Las búsquedas comienzan desde la derecha.
 Hay 3 campos de control:
\end_layout

\begin_layout Enumerate
3: cantidad de secciones en la hoja
\end_layout

\begin_layout Enumerate
9: cantidad de términos en la hoja
\end_layout

\begin_layout Enumerate
<p3>: posición relativa de <p2>
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ventajas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desventajas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se puede hacer una búsqueda 
\begin_inset Formula $n-$
\end_inset

aria del léxico.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desperdicia más espacio que el front coding.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Hashing perfecto y mínimo
\series default
: no se guardan los términos.
\end_layout

\begin_deeper
\begin_layout Enumerate
Se utiliza una función de hashing que es:
\end_layout

\begin_deeper
\begin_layout Enumerate
Perfecta: no produce colisiones.
\end_layout

\begin_layout Enumerate
Mínima: genera todos los valores posibles del espacio de direcciones.
\end_layout

\begin_layout Enumerate
Preservadora de orden: sean los strings 
\begin_inset Formula $s_{1}$
\end_inset

 y 
\begin_inset Formula $s_{2}$
\end_inset

.
 Entonces 
\begin_inset Formula $s_{1}<s_{2}\Longleftrightarrow f(s_{1})<f(s_{2})$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Compresión de listas invertidas
\end_layout

\begin_layout Enumerate
\begin_inset Formula $d-gaps$
\end_inset

: la lista invertida para el término 
\begin_inset Formula $t$
\end_inset

 de la forma 
\begin_inset Formula $\left\langle f_{t};d_{1},d_{2},\ldots,d_{f_{t}}\right\rangle $
\end_inset

 se almacena en forma ascendente mediante diferencias sucesivas: 
\begin_inset Formula 
\[
\left\langle f_{t};d_{1},d_{2}-d_{1},d_{3}-d_{2},\ldots,d_{f_{t}}-d_{f_{t}-1}\right\rangle 
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Como son más comunes las 
\begin_inset Formula $d-gaps$
\end_inset

 pequeñas, se puede utilizar codificación de longitud variable.
\end_layout

\end_deeper
\begin_layout Enumerate
Codificación alineada a bytes: representa números naturales con la mínima
 cantidad de bytes, usando los 2 bits más significativos del código para
 indicar la cantidad de bytes empleados.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rango de números representable 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Codificación en bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0\ldots2^{6}-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
00xxxxxx
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{6}\ldots2^{14}-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
01xxxxxx xxxxxxxx
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2^{14}\ldots2^{22}-1$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10xxxxxx xxxxxxxx xxxxxxxx
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Métodos que describen la distribución de probabilidad de las 
\begin_inset Formula $d-gaps$
\end_inset

: 
\end_layout

\begin_layout Enumerate

\series bold
Globales
\series default
: un mismo modelo para comprimir todas las listas invertidas.
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Parametrizados
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Bernoulli
\series default
: utiliza como parámetro la densidad de punteros del archivo invertido.
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

La probabilidad de cada distancia 
\begin_inset Formula $d-gap$
\end_inset

 es la distribución geométrica 
\begin_inset Formula $pr[x]=(1-p)^{x-1}p$
\end_inset

, donde 
\begin_inset Formula $p=\frac{f}{N\cdot n}$
\end_inset

 es la probabilidad de que un documento al azar posea un término al azar
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Frecuencia observada
\series default
: utiliza como parámetro la densidad exacta de punteros del archivo invertido.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
No parametrizados
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Binario
\series default
: 
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

La probabilidad de cada distancia 
\begin_inset Formula $d-gap$
\end_inset

 es uniforme (
\begin_inset Formula $pr[x]=\frac{1}{N}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Quotation
Un entero 
\begin_inset Formula $x$
\end_inset

 se codifica como 
\begin_inset Formula $x$
\end_inset

 en binario de 
\begin_inset Formula $\left\lceil \log_{2}N\right\rceil $
\end_inset

 bits (
\begin_inset Formula $N$
\end_inset

 es la cantidad de documentos).
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Unario
\series default
: 
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

La probabilidad de cada distancia 
\begin_inset Formula $d-gap$
\end_inset

 es 
\begin_inset Formula $pr[x]=2^{-x}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Un entero 
\begin_inset Formula $x\geq1$
\end_inset

 se codifica como 
\begin_inset Formula $x-1$
\end_inset

 bits en cero (uno) seguido de un bit en uno (cero).
\end_layout

\begin_layout Standard

\bar under
Ejemplo
\bar default
:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(x=5\right)\mbox{ en unario}=\underset{4\mbox{ bits en cero}}{\underbrace{0000}1}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Gamma
\series default
 (
\begin_inset Formula $\gamma$
\end_inset

):
\end_layout

\begin_deeper
\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

La probabilidad de cada distancia 
\begin_inset Formula $d-gap$
\end_inset

 es 
\begin_inset Formula $pr[x]\approx\frac{1}{2x^{2}}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Un entero 
\begin_inset Formula $x$
\end_inset

 se codifica como el número 
\begin_inset Formula $(1+\left\lfloor \log_{2}x\right\rfloor )$
\end_inset

 en 
\series bold
unario
\series default
, concatenado con el número (
\begin_inset Formula $x-2^{\left\lfloor \log_{2}x\right\rfloor }$
\end_inset

) en binario, en 
\begin_inset Formula $\left\lfloor \log_{2}x\right\rfloor $
\end_inset

 bits.
 (La parte en unario especifica cuántos bits se necesitan para codificar
 a 
\begin_inset Formula $x$
\end_inset

, y la parte en binario codifican 
\begin_inset Formula $x$
\end_inset

 en esa cantidad de bits).
\end_layout

\begin_layout Standard
Receta: 
\end_layout

\begin_layout Enumerate
Escribir el número en binario.
 
\end_layout

\begin_layout Enumerate
Restarle 1 a la cantidad de bits escritas en el paso anterior, y agregarle
 esa cantidad de ceros al principio.
 
\end_layout

\begin_layout Standard

\bar under
Ejemplo
\bar default
:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(x=5)\mbox{ en gamma}=00\underset{\mbox{5 en binario}}{\underbrace{101}}
\]

\end_inset


\end_layout

\begin_layout Standard
Decodificación: extraer el código unario 
\begin_inset Formula $c_{u}$
\end_inset

, y tratar los próximos 
\begin_inset Formula $c_{u}-1$
\end_inset

 bits como un número binario, para obtener el segundo valor 
\begin_inset Formula $c_{b}$
\end_inset

.
 El valor de 
\begin_inset Formula $x$
\end_inset

 se calcula como 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x=2^{c_{u}-1}+c_{b}
\]

\end_inset


\end_layout

\begin_layout Standard

\bar under
Ejemplo anterior
\bar default
: 
\begin_inset Formula $2^{3-1}+1=4+1=5$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Delta
\series default
 (
\begin_inset Formula $\delta$
\end_inset

): 
\end_layout

\begin_deeper
\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

La probabilidad de cada distancia 
\begin_inset Formula $d-gap$
\end_inset

 es 
\begin_inset Formula $pr[x]\approx\frac{1}{2x(\log x)^{2}}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Un entero 
\begin_inset Formula $x$
\end_inset

 se codifica como el número 
\begin_inset Formula $(1+\left\lfloor \log_{2}x\right\rfloor )$
\end_inset

 en 
\series bold
gamma
\series default
, concatenado con el número (
\begin_inset Formula $x-2^{\left\lfloor \log_{2}x\right\rfloor }$
\end_inset

) en binario, en 
\begin_inset Formula $\left\lfloor \log_{2}x\right\rfloor $
\end_inset

 bits.
 (La parte en gamma especifica cuántos bits se necesitan para codificar
 a 
\begin_inset Formula $x$
\end_inset

, y la parte en binario codifican 
\begin_inset Formula $x$
\end_inset

 en esa cantidad de bits).
\end_layout

\begin_layout Standard
La codificación en 
\begin_inset Formula $\delta$
\end_inset

 ocupa más espacio que la codificación 
\begin_inset Formula $\gamma$
\end_inset

 cuando 
\begin_inset Formula $x<15$
\end_inset

.
 Cuando 
\begin_inset Formula $x\geq15$
\end_inset

, 
\begin_inset Formula $\delta$
\end_inset

 ocupa menos espacio.
\end_layout

\begin_layout Standard
El 0 no se puede representar.
\end_layout

\begin_layout Standard

\bar under
Ejemplo
\bar default
: 
\begin_inset Formula 
\begin{eqnarray*}
(x=5)\mbox{ en delta } & = & (1+2)\mbox{ en gamma, }(5-2^{2})\mbox{ en binario de 2 bits}\\
 & = & 011,01
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Decodificación: extraer el código gamma 
\begin_inset Formula $c_{g}$
\end_inset

, y tratar los próximos 
\begin_inset Formula $c_{g}-1$
\end_inset

 bits como un número binario, para obtener el segundo valor 
\begin_inset Formula $c_{b}$
\end_inset

.
 El valor de 
\begin_inset Formula $x$
\end_inset

 se calcula como 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x=2^{c_{g}-1}+c_{b}
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Locales
\series default
: las listas invertidas de cada término se comprimen de acuerdo a un parámetro
 (generalmente, la frecuencia del término).
 Comprimen mejor que los métodos globales, pero son más difíciles de implementar.
 
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Bernoulli
\series default
: implementado con 
\series bold
códigos de Golomb
\series default
, que aproxima una codificación con Huffman: usa un parámetro ajustable
 
\begin_inset Formula $g$
\end_inset

 para codificar un entero 
\begin_inset Formula $x>0$
\end_inset

 en dos partes: el cociente 
\begin_inset Formula $q$
\end_inset

 y el residuo 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q+1$
\end_inset

 en unario, donde 
\begin_inset Formula $q=\left\lfloor \frac{x}{g}\right\rfloor $
\end_inset

.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $r=x-qg$
\end_inset

 en binario de 
\begin_inset Formula $\left\lceil \log_{2}g\right\rceil $
\end_inset

 bits.
 
\end_layout

\begin_deeper
\begin_layout Standard
Puede demostrarse que si 
\begin_inset Formula $g$
\end_inset

 satisface 
\begin_inset Formula 
\[
(1-p)^{g}+(1-p)^{g+1}\leq1<(1-p)^{g-1}+(1-p)^{g}
\]

\end_inset


\end_layout

\begin_layout Standard
el código es óptimo.
 (Es decir, 
\begin_inset Formula $g$
\end_inset

 se relaciona con la probabilidad 
\begin_inset Formula $p$
\end_inset

 de que un término se encuentre en un documento).
 Entonces el parámetro 
\begin_inset Formula $g$
\end_inset

 óptimo es, para cada término:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
g_{optimo_{term}} & = & round\left(\frac{\log_{2}(2-p_{term})}{-\log_{2}(1-p_{term})}\right)\\
p_{term} & = & \frac{\mbox{\# docs que tienen el term}}{\mbox{\# docs}}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b & = & \left\lceil \log_{2}g\right\rceil \\
y & = & 2^{b}-g\\
\mbox{Si }r<y & \implies & r\mbox{ en }b-1\mbox{ bits}\\
\mbox{\mbox{Si }}r\geq y & \implies & y+r\mbox{ en }b\mbox{ bits}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Nota: si 
\begin_inset Formula $p>0.5$
\end_inset

, el código de Golomb es más efectivo si el archivo invertido se complementa
 antes de comprimir.
\end_layout

\begin_layout Standard
El parámetro 
\begin_inset Formula $g$
\end_inset

 se debe almacenar al comienzo de cada lista invertida, para poder descomprimirl
a.
\end_layout

\begin_layout Standard
Problema: si a un término le agrego un nuevo documento, hay que volver a
 codificar la lista afectada (porque cambió 
\begin_inset Formula $p_{term}$
\end_inset

 y por ende 
\begin_inset Formula $g$
\end_inset

).
\end_layout

\begin_layout Standard

\bar under
Decodificación
\bar default
: Se tiene la siguiente cadena 
\begin_inset Formula 
\[
110|100000010|10|00001101
\]

\end_inset

 y si sabe que contiene 2 números con 
\begin_inset Formula $g=385$
\end_inset

.
\begin_inset Formula 
\begin{eqnarray*}
b & = & \left\lceil \log_{2}g\right\rceil =9\\
y & = & 2^{b}-g=127
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Primer número 
\begin_inset Formula $x_{1}$
\end_inset

:
\end_layout

\begin_layout Itemize
Prefijo: 
\begin_inset Formula $q+1=110=3\implies q=2$
\end_inset


\end_layout

\begin_layout Itemize
Sufijo: 
\begin_inset Formula $b-1$
\end_inset

 bits siguientes al prefijo 
\begin_inset Formula $\implies10000001=129$
\end_inset

.
 Como es mayor/igual a 
\begin_inset Formula $y$
\end_inset

, tomamos un bit más 
\begin_inset Formula $\implies100000010=258$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $r=sufijo-y=131$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{1}=g\times q+r=901
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Segundo número 
\begin_inset Formula $x_{2}$
\end_inset

:
\end_layout

\begin_layout Itemize
Prefijo: 
\begin_inset Formula $q+1=10=2\implies q=1$
\end_inset


\end_layout

\begin_layout Itemize
Sufijo: 
\begin_inset Formula $b-1$
\end_inset

 bits siguientes al prefijo 
\begin_inset Formula $\implies$
\end_inset


\begin_inset Formula $00001101=13$
\end_inset

.
 Como es menor a 
\begin_inset Formula $y$
\end_inset

, ese es el sufijo.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $r=sufijo=13$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{2}=g\times q+r=398
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/unary delta gamma.jpg
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Unario, delta, gamma y Golomb
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Colecciones dinámicas
\end_layout

\begin_layout Standard
La organización de las listas invertidas en el archivo secuencial depende
 de la política de actualización del índice: 
\end_layout

\begin_layout Itemize
Actualizaciones por reconstrucción total (para actualizaciones poco frecuentes):
\end_layout

\begin_deeper
\begin_layout Itemize
Las listas invertidas son 
\series bold
registros de longitud variable
\series default
.
 
\end_layout

\begin_layout Itemize
El offset en el archivo del léxico es el offset del comienzo del registro
 de longitud variable.
 
\end_layout

\end_deeper
\begin_layout Itemize
Actualizaciones incrementales (para actualizaciones muy frecuentes):
\end_layout

\begin_deeper
\begin_layout Itemize
Las listas invertidas son 
\series bold
bloques de tamaño fijo
\series default
, con un campo extra que dice el término de la lista.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
Bloque\left(cantListas:1,\left(offsetLista\right)cantListas,Lista\left(idT:2,cantDocs:2,\left(doc:2\right)cantDocs\right)cantListas\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
Si el término leído no estaba en el índice:
\end_layout

\begin_deeper
\begin_layout Itemize
El archivo secuencial de términos se actualiza normalmente.
 
\end_layout

\begin_layout Itemize
Se inserta la lista invertida en un bloque.
 Para esto, podría ser necesario relocalizar listas ya existentes en un
 bloque, para hacer lugar a la nueva.
 
\end_layout

\end_deeper
\begin_layout Itemize
Si el término leído estaba en el índice:
\end_layout

\begin_deeper
\begin_layout Itemize
Se actualiza la lista invertida del término en el bloque.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
El offset en el archivo del léxico es el offset del comienzo del bloque.
 
\end_layout

\begin_layout Itemize
Los bloques pueden enlazarse, para permitir almacenar listas invertidas
 muy grandes.
 
\end_layout

\end_deeper
\begin_layout Section
Google y las consultas por Internet
\end_layout

\begin_layout Standard
Un documento es una página web.
\end_layout

\begin_layout Standard
Problemas de las búsquedas en Internet:
\end_layout

\begin_layout Enumerate
Internet es una colección heterogénea no controlable, de enormes proporciones.
 Hay que eliminar enlaces muertos, páginas duplicadas, o páginas que tengan
 spam.
\end_layout

\begin_layout Enumerate
Hay que indexar contenido no indexable (imágenes, etc.).
\end_layout

\begin_layout Enumerate
El proceso de 
\emph on
crawling
\emph default
 puede aumentar el tráfico de los servidores de las páginas web
\end_layout

\begin_layout Enumerate
No es posible indexar todas las páginas web existentes, por dos razones:
\end_layout

\begin_deeper
\begin_layout Enumerate
El espacio de almacenamiento es limitado,
\end_layout

\begin_layout Enumerate
En cierto punto el 
\emph on
crawler
\emph default
 deberá visitar páginas ya indexadas para buscar cambios.
\end_layout

\end_deeper
\begin_layout Enumerate
Hay muchos errores en los documentos y en las consultas
\end_layout

\begin_layout Enumerate
Usar la información presente en hipertexto para producir mejores resultados
\end_layout

\begin_layout Enumerate
Se debe automatizar la indexación, porque los índices armados y mantenidos
 por personas son subjetivos, caros para armar, lentos para mejorar, y no
 cubren todos los temas
\end_layout

\begin_layout Enumerate
No se puede medir el 
\emph on
recall
\end_layout

\begin_layout Enumerate
Usuarios inexpertos
\end_layout

\begin_layout Standard
Se necesitan tres cosas:
\end_layout

\begin_layout Enumerate
Algoritmos de 
\emph on
crawling
\emph default
 rápidos, 
\end_layout

\begin_layout Enumerate
Mecanismos que almacenen eficientemente los índices y, opcionalmente, los
 documentos mismos
\end_layout

\begin_layout Enumerate
Algoritmos de resolución de consulta rápidos y que devuelvan resultados
 precisos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/google.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Arquitectura de Google.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\emph on
Crawling
\end_layout

\begin_layout Standard

\series bold
\emph on
Crawling
\series default
\emph default
: recorrer páginas web recursivamente para agregarlas al índice, obteniendo
 las páginas más importantes primero, y visitando páginas frecuentemente
 para estar al tanto de los cambios.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cola de prioridad = {} // la cabeza de esta cola tiene mas prioridad que
 el resto
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

indexar(seed url):
\end_layout

\begin_layout Plain Layout

	si (url se puede indexadar) // verifica robots.txt
\end_layout

\begin_layout Plain Layout

		si (url no fue indexada) // verifica duplicados usando checksums
\end_layout

\begin_layout Plain Layout

			guardar url
\end_layout

\begin_layout Plain Layout

			para cada url dentro de seed url
\end_layout

\begin_layout Plain Layout

				agregar url a la cola de prioridad
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	remover url de cola prioridad e indexarla
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algoritmo de crawling
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El proceso de 
\emph on
crawling
\emph default
 se hace con cientos de máquinas distribuidas.
 Una función de hashing determina qué máquina debe indexar qué URL.
\end_layout

\begin_layout Subsection

\emph on
Storing
\end_layout

\begin_layout Standard
Google guarda los documentos que indexa en forma comprimida.
\end_layout

\begin_layout Standard
Google usa datos de proximidad para las búsquedas.
\end_layout

\begin_layout Standard
Google guarda datos de presentación visual, como las 
\series bold
negritas
\series default
 y el 
\bar under
subrayado
\bar default
 de palabras para modificar el peso de las palabras.
\end_layout

\begin_layout Subsection

\emph on
Searching
\end_layout

\begin_layout Standard
La web, como conjunto de páginas relacionadas entre sí mediante links, puede
 ser representada mediante un grafo dirigido, en el que cada nodo es una
 página web, y cada arista es un link.
\end_layout

\begin_layout Standard
Para rankear una página se utilizan dos cosas:
\end_layout

\begin_layout Enumerate
Estructura de links,
\end_layout

\begin_layout Enumerate

\emph on
Anchor text
\emph default
 (lo que aparece en los links).
\end_layout

\begin_deeper
\begin_layout Enumerate
Proveen una descripción muy buena de las páginas a las que apuntan
\end_layout

\begin_layout Enumerate
Proveen una descripción de documentos no indexables (imágenes, programas,
 etc.)
\end_layout

\end_deeper
\begin_layout Standard
Dada una página web 
\begin_inset Formula $x$
\end_inset

, puede definirse su importancia, 
\begin_inset Formula $I(x)$
\end_inset

, en alguna de las siguientes formas:
\end_layout

\begin_layout Enumerate
Similitud con una consulta 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Enumerate
Contador de citaciones (
\emph on
backlink count
\emph default
), es la cantidad de links en la Web hacia 
\begin_inset Formula $x$
\end_inset

.
 Este método asume que todos los links son iguales.
\end_layout

\begin_layout Enumerate

\emph on
Forward link count
\emph default
, es la cantidad de links que emanan de 
\begin_inset Formula $x$
\end_inset

.
 Bajo esta métrica, los sitios webs como ser los directorios son muy importantes.
\end_layout

\begin_layout Enumerate
Localización.
 
\begin_inset Formula $I(x)$
\end_inset

 es una función de la localización de 
\begin_inset Formula $x$
\end_inset

, no de sus contenidos.
 Por ejemplo, páginas que terminan en 
\begin_inset Quotes eld
\end_inset

.com
\begin_inset Quotes erd
\end_inset

 son muy importantes, o páginas que contengan el string 
\begin_inset Quotes eld
\end_inset

home
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
PageRank, es la suma ponderada de los 
\emph on
backlinks
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
PR_{i}(x)=(1-\alpha)+\alpha\cdot\sum_{i=1}^{n}\left(\frac{PR(T_{i})}{C(T_{i})}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
donde: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $PR_{i}(x)$
\end_inset

 es el PageRank de la página web 
\begin_inset Formula $x$
\end_inset

 para la iteración 
\begin_inset Formula $i$
\end_inset

 (
\begin_inset Formula $PR_{0}(x)=1$
\end_inset

 para todo 
\begin_inset Formula $x$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\sum_{\forall x}PR(x)=1
\]

\end_inset


\end_layout

\begin_layout Standard
El algoritmo es iterativo hasta que los valores converjan.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\in(0,1)$
\end_inset

 es el factor de amortiguación, es constante.
 En general, 
\begin_inset Formula $\alpha=0.85$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $T_{i}$
\end_inset

 es una página que posee un link a 
\begin_inset Formula $x$
\end_inset

, una 
\begin_inset Quotes eld
\end_inset

citación
\begin_inset Quotes erd
\end_inset

 de 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $C(x)$
\end_inset

 es la cantidad de links hacia afuera de una página 
\begin_inset Formula $x$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Standard
PageRank es una medida objetiva de la 
\begin_inset Quotes eld
\end_inset

importancia
\begin_inset Quotes erd
\end_inset

 de una página web, contando las citaciones de la misma.
\end_layout

\begin_layout Standard
PageRank puede pensarse como un modelo del comportamiento de un usuario.
 Asumir que hay un usuario que recibe una página web al azar, y hace clics
 continuamente, hasta que se aburre y comienza en otra página aleatoria.
 La probabilidad de que el usuario visite la página 
\begin_inset Formula $x$
\end_inset

 es 
\begin_inset Formula $PR(x)$
\end_inset

.
 La probabilidad de que el usuario se aburra y comience el proceso de nuevo
 es 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Parse the query.
 
\end_layout

\begin_layout Plain Layout

Convert words into wordIDs.
 
\end_layout

\begin_layout Plain Layout

Seek to the start of the doclist in the short barrel for every word.
 
\end_layout

\begin_layout Plain Layout

Scan through the doclists until there is a document that matches all the
 search terms.
 
\end_layout

\begin_layout Plain Layout

Compute the rank of that document for the query.
\end_layout

\begin_layout Plain Layout

If we are in the short barrels and at the end of any doclist, seek to the
 start of the doclist 	in the full barrel for every word and go to step
 4.
\end_layout

\begin_layout Plain Layout

If we are not at the end of any doclist go to step 4.
 
\end_layout

\begin_layout Plain Layout

Sort the documents that have matched by rank and return the top k.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Resolución de consultas.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Algoritmo de construcción de índice
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

indice.py
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Compresión
\end_layout

\begin_layout Section
Introducción a la compresión
\end_layout

\begin_layout Standard

\series bold
Teoría de la información
\series default
: estudio de los procesos que se realizan sobre la información.
 Provee una medida de la información.
\end_layout

\begin_layout Standard
En un mensaje, hay más información cuando la probabilidad de un mensaje
 es baja.
 Por ejemplo, si leemos el 
\emph on
string
\emph default
 
\begin_inset Quotes eld
\end_inset

Argentin
\begin_inset Quotes erd
\end_inset

, la información que recibimos es la misma que si leemos 
\begin_inset Quotes eld
\end_inset

Argentina
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Compresión
\series default
: representación de información utilizando menos bits.
 Hay dos tipos de algoritmos compresores: 
\end_layout

\begin_layout Itemize

\emph on
Con pérdida / lossy / compactadores
\emph default
: se pierde información, se gana tasa de compresión.
 Se utiliza para comprimir imágenes, audio o video, en donde la pérdida
 de calidad no es notoria.
 
\end_layout

\begin_layout Itemize

\emph on
Sin pérdida / lossless
\emph default
: estos compresores permiten, a partir del archivo comprimido, recrear el
 archivo original tal cual era.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Compresores estadísticos
\emph default
: se basan exclusivamente en la probabilidad de aparición de los símbolos.
 
\end_layout

\begin_layout Itemize

\emph on
Compresores no estadísticos
\end_layout

\begin_deeper
\begin_layout Itemize
RLE (Run Length Encoding): codifican secuencias repetidas.
 
\end_layout

\begin_layout Itemize
Predictores 
\end_layout

\begin_layout Itemize
Por sustitución 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Compresión estática
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Compresión dinámica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de pasadas al archivo 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Una pasada para obtener estadísticas del archivo, y otra pasada para comprimir.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Una pasada para obtener estadísticas y para comprimir.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Velocidad de compresión 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lento.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rápido.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nivel de compresion 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Muy bueno.
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bueno.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Compresión estática y dinámica.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Entropía
\series default
: grado de desorden de una fuente.
\end_layout

\begin_layout Standard
Sea una fuente 
\begin_inset Formula $F$
\end_inset

, la entropía de 
\begin_inset Formula $F$
\end_inset

 se define como 
\begin_inset Formula 
\[
H(F)=\sum_{i=0}^{n}P_{i}\cdot\left(-\log_{2}(P_{i})\right)
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Códigos prefijos
\series default
: código con la 
\begin_inset Quotes eld
\end_inset

propiedad de prefijo
\begin_inset Quotes erd
\end_inset

: ninguna palabra de código es prefijo de cualquier otra palabra de código
 del conjunto.
 Ejemplos: 
\end_layout

\begin_layout Enumerate
A=0, B=10, C=11 tiene la propiedad de prefijo.
 
\end_layout

\begin_layout Enumerate
A=0, B=1, C=10, D=11 no tiene la propiedad de prefijo, porque 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 es prefijo de 
\begin_inset Quotes eld
\end_inset

10
\begin_inset Quotes erd
\end_inset

 y de 
\begin_inset Quotes eld
\end_inset

11
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Section
Marca de fin de archivo
\end_layout

\begin_layout Enumerate
Comprimir el archivo.
 Agregar un 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 al final, y completar con ceros hasta el final del byte.
 El descompresor empezará por el final, leyendo los bits en cero y eliminándolos.
 Cuando llega al 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 lo elimina, se detiene, y comienza a descomprimir por el principio.
 
\end_layout

\begin_layout Enumerate
Indicar la longitud del archivo comprimido al inicio.
 Este método no sirve para los compresores dinámicos, puesto que la longitud
 del archivo no se conoce hasta procesarlo todo.
 
\end_layout

\begin_layout Enumerate
Utilizar un caracter extra como EOF.
 
\end_layout

\begin_layout Section
Compresión por Huffman
\end_layout

\begin_layout Standard
Es un compresor estadístico.
 Se construye un árbol de símbolos, y a cada símbolo se le asigna un código
 binario que se deduce recorriendo el árbol.
\end_layout

\begin_layout Standard
La codificación Huffman es una técnica óptima para construir códigos prefijo
 de longitud variable.
\end_layout

\begin_layout Subsection
Huffman estático
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Enumerate

Crear un nodo hoja para cada símbolo.
 Agregar cada nodo a la cola de prioridad.
 
\end_layout

\begin_layout Enumerate

Mientras haya más de 1 nodo en la cola:
\end_layout

\begin_deeper
\begin_layout Enumerate

Quitar los 2 nodos de menor frecuencia de la cola.
 
\end_layout

\begin_layout Enumerate

Crear un nuevo nodo con los 2 nodos anteriores como hijos.
 Su frecuencia es igual a la suma de las frecuencias de sus hijos.
 
\end_layout

\begin_layout Enumerate

Agregar el nuevo nodo a la cola de prioridad.
 
\end_layout

\end_deeper
\begin_layout Enumerate

El nodo restante es la raíz; el árbol está completo.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Armado de árbol Huffman.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Enumerate

Primera pasada al archivo para armar una tabla de frecuencias que contiene
 como clave el símbolo, y como valor la frecuencia de ese símbolo en el
 archivo.
 
\end_layout

\begin_layout Enumerate

Generación del árbol.
 
\end_layout

\begin_layout Enumerate

Emitir la tabla de frecuencias al archivo comprimido.
 
\end_layout

\begin_layout Enumerate

Segunda pasada al archivo: mientras queden caracteres sin leer del archivo:
\end_layout

\begin_deeper
\begin_layout Enumerate

Leer el caracter siguiente, 
\end_layout

\begin_layout Enumerate

Emitir su código, que se obtiene del árbol.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Huffman estático: compresor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Enumerate

Leer la tabla de frecuencias.
 
\end_layout

\begin_layout Enumerate

Generar el árbol a partir de la tabla.
 
\end_layout

\begin_layout Enumerate

Mientras queden códigos sin leer del archivo comprimido:
\end_layout

\begin_deeper
\begin_layout Enumerate

Leer el código siguiente 
\end_layout

\begin_layout Enumerate

Buscarlo en el árbol 
\end_layout

\begin_layout Enumerate

Emitir su símbolo correspondiente.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Huffman estático: descompresor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Huffman dinámico
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Enumerate

Armar una tabla de frecuencias que incluye todos los caracteres posibles,
 todos con frecuencia igual a 1.
 
\end_layout

\begin_layout Enumerate

Generar el árbol.
 
\end_layout

\begin_layout Enumerate

Mientras queden caracteres sin procesar:
\end_layout

\begin_deeper
\begin_layout Enumerate

Leer el caracter siguiente.
 
\end_layout

\begin_layout Enumerate

Comprimirlo.
 
\end_layout

\begin_layout Enumerate

Actualizar la tabla de frecuencias.
 
\end_layout

\begin_layout Enumerate

Rearmar el árbol.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Huffman dinámico: compresor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Criptografía
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard

\series bold
Esteganografía:
\series default
 esconder información dentro de otra información.
\end_layout

\begin_layout Standard

\series bold
Criptografía
\series default
: ciencia que estudia la transformación de un mensaje en un código, de forma
 tal que a partir de ese código solo algunas personas puedan recuperar el
 mensaje original.
 Para ello se utiliza una palabra clave.
 El código resultante solo puede ser descifrado por las personas que conozcan
 la palabra clave.
\end_layout

\begin_layout Standard
Usos de la Criptografía:
\end_layout

\begin_layout Enumerate
Encriptación de información crítica para 
\end_layout

\begin_deeper
\begin_layout Enumerate
almacenarla en computadoras
\end_layout

\begin_layout Enumerate
enviarla por una red insegura
\end_layout

\end_deeper
\begin_layout Enumerate
Certificación de identidad
\end_layout

\begin_layout Standard
Objetivos de la Criptografía:
\end_layout

\begin_layout Itemize

\series bold
Confidencialidad
\series default
: poder decidir quién puede acceder a cierta información.
\end_layout

\begin_layout Itemize

\series bold
Integridad
\series default
: poder asegurar que un mensaje no fue corrompido en la transmisión (por
 error o con intención), o poder darse cuenta cuando lo fue.
\end_layout

\begin_layout Itemize

\series bold
Autenticación
\series default
: poder asegurar que algo es lo que dice ser.
\end_layout

\begin_deeper
\begin_layout Standard
Sistemas de autenticación:
\end_layout

\begin_layout Itemize
Basados en algo conocido (ejemplo: una contraseña).
\end_layout

\begin_layout Itemize
Basados en algo poseído (ejemplo: una tarjeta de identidad).
\end_layout

\begin_layout Itemize
Basados en una característica del usuario (ejemplo: huellas dactilares).
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
No repudio
\series default
: evitar que el emisor o el receptor de un mensaje nieguen, respectivamente,
 la emisión o recepción del mismo.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\mbox{No repudio }\implies\mbox{Autenticación}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Criptosistema
\series medium
:
\series default
 formado por cinco elementos
\end_layout

\begin_layout Enumerate
\begin_inset Formula $M$
\end_inset

 es el conjunto de todos los posibles mensajes o textos planos (
\emph on
plaintext
\emph default
) que podemos querer encriptar.
\end_layout

\begin_deeper
\begin_layout Itemize
Cuanta más entropía tenga el mensaje (
\begin_inset Formula $H(M)\approx1$
\end_inset

), más difícil será romper el criptosistema.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $C$
\end_inset

 es el conjunto de todos los posibles códigos que podemos obtener al encriptar
 (
\emph on
cyphertext
\emph default
).
\end_layout

\begin_layout Enumerate
\begin_inset Formula $K$
\end_inset

 es el conjunto de todas las claves que podemos usar.
 El tamaño de este conjunto es el 
\emph on
keyspace
\emph default
 o 
\begin_inset Formula $|K|$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Pueden existir ciertas 
\series bold
claves débiles
\series default
 tales que 
\begin_inset Formula $E_{k}\left(E_{k}(m)\right)=m$
\end_inset


\end_layout

\begin_layout Itemize
Pueden existir ciertas 
\series bold
claves
\series default
 
\series bold
semi débiles
\series default
 tales que 
\begin_inset Formula $E_{k_{1}}\left(E_{k_{2}}(m)\right)=m$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $|K|=|M|$
\end_inset

 implica seguridad perfecta, y el reuso de claves destruye esta propiedad
 (porque son vulnerables a ataques por replay).
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $E$
\end_inset

 es la función de encriptación.
 Existe una transformación diferente 
\begin_inset Formula $E_{k}$
\end_inset

 para cada valor posible de la clave 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D$
\end_inset

 es la función de desencriptación.
\end_layout

\begin_layout Standard
Todo criptosistema debe cumplir:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
D_{k}\left(E_{k}(m)\right)=m
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Principio de Kerckhoff
\series default
: un criptosistema debería ser seguro incluso cuando se conoce todo el algoritmo
, excepto la clave.
 No se debe confiar en 
\begin_inset Quotes eld
\end_inset

seguridad basada en obscuridad
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Criptoanálisis
\series default
: romper un criptosistema, obtener el mensaje a partir del código cifrado.
\end_layout

\begin_layout Section
Algoritmos de encriptación
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/cipher_types.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Taxonomía de algoritmos.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se los divide en dos grupos:
\end_layout

\begin_layout Itemize
Algoritmos de clave privada o 
\series bold
simétricos
\series default
.
 Se utiliza una sola clave para encriptar y desencriptar.
\end_layout

\begin_deeper
\begin_layout Itemize
Encriptación: mensaje + clave = código
\end_layout

\begin_layout Itemize
Desencriptación: código + clave = mensaje
\end_layout

\begin_layout Standard
Desventajas:
\end_layout

\begin_layout Itemize
¿Cómo transmitir la clave de forma segura?
\end_layout

\begin_layout Itemize
¿Qué pasa si se roban la clave?
\end_layout

\begin_layout Itemize
Para establecer una comunicación segura entre 
\begin_inset Formula $n$
\end_inset

 personas requiere una clave para cada par de usuarios: en total, se necesitan
 
\begin_inset Formula $\frac{n\left(n-1\right)}{2}$
\end_inset

 claves.
\end_layout

\begin_layout Standard
Son algoritmos rápidos.
\end_layout

\begin_layout Standard
Se basan en la confusión y la difusión de la redundancia del mensaje.
\end_layout

\end_deeper
\begin_layout Itemize
Algoritmos de clave pública o 
\series bold
antisimétricos
\series default
.
 Se utilizan dos claves para encriptar, una es privada y la otra es pública.
 Cada persona tiene un par de estas claves.
\end_layout

\begin_deeper
\begin_layout Standard
El conocimiento de la clave pública no debería permitir calcular la clave
 privada.
\end_layout

\begin_layout Standard
Estos algoritmos suelen basarse en problemas matemáticos cuyo tiempo de
 resolución sea muy alto.
\end_layout

\begin_layout Standard
Los métodos criptográficos de este tipo garantizan que un par de claves
 no se puede generar más de una vez.
\end_layout

\begin_layout Standard
Los métodos de encriptación y desencriptación son de público conocimiento.
 La fortaleza del criptosistema debe residir solamente en la clave.
\end_layout

\begin_layout Standard
Resuelven el problema de la comunicación entre desconocidos sin tener que
 ponerse de acuerdo en una clave.
\end_layout

\begin_layout Itemize
Encriptación con clave privada y desencriptación con clave pública: provee
 autenticación (una persona puede encriptar, pero cualquiera puede desencriptar).
\end_layout

\begin_layout Itemize
Encriptación con clave pública y desencriptación con clave privada: provee
 confidencialidad y no repudio del receptor (cualquiera puede encriptar,
 pero solo una puede desencriptar).
\end_layout

\begin_layout Standard
Desventajas:
\end_layout

\begin_layout Itemize
¿Cómo obtener la clave pública de forma segura?
\end_layout

\begin_layout Itemize
¿Qué pasa si convenientemente 
\begin_inset Quotes eld
\end_inset

perdemos
\begin_inset Quotes erd
\end_inset

 nuestra clave privada? Podríamos repudiar una firma digital...
 Solución: diseñar el algoritmo de tal forma que sea imposible para los
 usuarios acceder a sus claves privadas.
\end_layout

\begin_layout Itemize
La encriptación y desencriptación son lentas (1000 más lentas que un algoritmo
 simétrico).
\end_layout

\begin_layout Itemize
Son vulnerables a ataques por texto plano escogido.
 Si hay 
\begin_inset Formula $n$
\end_inset

 textos planos posibles, y se conoce 
\begin_inset Formula $C=E_{k_{pub}}\left(M\right)$
\end_inset

, para obtener 
\begin_inset Formula $M$
\end_inset

 solo hay que encriptar los 
\begin_inset Formula $n$
\end_inset

 textos planos posibles y compararlos con 
\begin_inset Formula $C$
\end_inset

 (recordar que la clave pública es conocida).
 Cuando son iguales, se descubrió 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Algoritmos 
\series bold
híbridos
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
En la vida real se suelen utilizar algoritmos simétricos, enviando la clave
 utilizando mecanismos asimétricos (porque la clave es corta).
 La clave de sesión es la que se utiliza como clave del algoritmo simétrico,
 y una vez que se termina la comunicación, la misma se desecha.
\end_layout

\begin_layout Enumerate
Bob le envía a Alice su clave pública, 
\begin_inset Formula $k_{pub_{Bob}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alice genera una clave de sesión 
\series bold
aleatoria
\series default
 
\begin_inset Formula $K$
\end_inset

, la encripta con 
\begin_inset Formula $k_{pub_{Bob}}$
\end_inset

, y se la envía a Bob.
\end_layout

\begin_layout Enumerate
Bob desencripta el mensaje 
\begin_inset Formula $E_{k_{pub_{Bob}}}\left(K\right)$
\end_inset

 con su clave privada, recuperando la clave 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alice y Bob se comunican con 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Estructura de grupo
\series default
: propiedad de un algoritmo de encriptación que satisface:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\forall k_{1},k_{2}(k_{1}\neq k_{2})\,\exists k_{3}\,:\, E_{k_{2}}\left(E_{k_{1}}(m)\right)=E_{k_{3}}(m)
\]

\end_inset


\end_layout

\begin_layout Standard
Es decir, que encriptar con una clave 
\begin_inset Formula $k_{1}$
\end_inset

 y luego con una clave 
\begin_inset Formula $k_{2}$
\end_inset

 no es más seguro que encriptar sólo con 
\begin_inset Formula $k_{1}$
\end_inset

.
 Esta propiedad 
\series bold
no
\series default
 es deseable.
\end_layout

\begin_layout Section
Ejemplos de criptosistemas de clave privada
\end_layout

\begin_layout Standard

\series bold
Cifrados por bloque
\series default
:
\end_layout

\begin_layout Itemize
Transposiciones
\end_layout

\begin_deeper
\begin_layout Itemize
Común: el caracter 
\begin_inset Formula $i$
\end_inset

 del mensaje 
\begin_inset Formula $m$
\end_inset

 se pondrá en una posición 
\begin_inset Formula $k$
\end_inset

 en el mensaje encriptado.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Tiene estructura de grupo.
\end_layout

\end_deeper
\begin_layout Itemize
Por columnas: el caracter 
\begin_inset Formula $i$
\end_inset

 del mensaje 
\begin_inset Formula $m$
\end_inset

 se pondrá en una posición 
\begin_inset Formula $k$
\end_inset

 en el mensaje encriptado, donde 
\begin_inset Formula $k$
\end_inset

 depende de una clave de longitud 
\begin_inset Formula $l$
\end_inset

.
 La clave 
\series bold
no
\series default
 puede tener caracteres repetidos.
\end_layout

\begin_deeper
\begin_layout Itemize
El ataque por análisis de frecuencias no sirve.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|K\right|=l!$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Clave = (6,3,4,7,5,2,1)
\end_layout

\begin_layout Plain Layout
Mensaje = ESTABLECENLASSSIGUIENTESCARAC
\end_layout

\begin_layout Plain Layout
Mensaje en columnas: 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Mensa encriptado: 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ejemplo de transposición por columnas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Sustituciones
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Monoalfabéticas
\series default
: un caracter original se encripta con un caracter.
\end_layout

\begin_layout Itemize

\series bold
Polialfabéticas
\series default
: 
\begin_inset Formula $n$
\end_inset

 caracteres originales se encriptan en 
\begin_inset Formula $m$
\end_inset

 caracteres (
\begin_inset Formula $n\neq m$
\end_inset

).
\end_layout

\begin_layout Itemize

\series bold
Homofónica
\series default
: un caracter original 
\begin_inset Formula $x$
\end_inset

 se encripta en varios caracteres.
 Cuanto más frecuente sea 
\begin_inset Formula $x$
\end_inset

 en el mensaje, más cantidad de símbolo se le asignarán.
 De esta forma se evita el ataque por análisis de frecuencias.
\end_layout

\begin_layout Itemize

\series bold
Poligráfica
\series default
: 
\begin_inset Formula $n$
\end_inset

 caracteres originales se encriptan en 
\begin_inset Formula $n$
\end_inset

 caracteres.
 La sustitución aplicada a cada caracter varía en función de la posición
 que éste ocupe dentro del mensaje.
\end_layout

\end_deeper
\begin_layout Itemize
Productos: generar 
\begin_inset Quotes eld
\end_inset

rondas
\begin_inset Quotes erd
\end_inset

 donde en cada una se realiza una sustitución o una transposición.
 La clave puede variar entre cada ronda, y la misma determina el orden de
 las operaciones.
\end_layout

\begin_layout Subsection
Scytale
\end_layout

\begin_layout Itemize
Es un palo en el cual se escribe un mensaje, en tiras.
\end_layout

\begin_layout Itemize
La clave es el tamaño del palo.
\end_layout

\begin_layout Itemize
Cifrado por transposición.
\end_layout

\begin_layout Subsection
CAESAR
\end_layout

\begin_layout Itemize
Sustitución monoalfabética
\end_layout

\begin_layout Itemize
Muy malo
\end_layout

\begin_layout Itemize
Es el sistema mas viejo conocido
\end_layout

\begin_layout Itemize
\begin_inset Formula $k\in K=\{1,2,\ldots,26\}$
\end_inset

 (cantidad de caracteres del alfabeto)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|K\right|=26$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{k}(char)=(char+k)\mod26$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{k}(char)=(char-k)\mod26$
\end_inset


\end_layout

\begin_layout Itemize
Criptoanálisis: ataque por fuerza bruta.
\end_layout

\begin_layout Subsection
Vigenere
\end_layout

\begin_layout Itemize
Sustitución polialfabética.
\end_layout

\begin_layout Itemize
La clave 
\begin_inset Formula $k$
\end_inset

 es un conjunto de 
\begin_inset Formula $l$
\end_inset

 letras, 
\begin_inset Formula $\{k_{1},k_{2},\ldots,k_{l}\}$
\end_inset

.
\end_layout

\begin_layout Itemize
Para encriptar:
\end_layout

\begin_deeper
\begin_layout Itemize
Suponemos un alfabeto de 
\begin_inset Formula $26$
\end_inset

 caracteres.
\end_layout

\begin_layout Itemize
Separar el mensaje 
\begin_inset Formula $m$
\end_inset

 en grupos de 
\begin_inset Formula $l$
\end_inset

 caracteres.
\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{k}(m_{i})=\left[m_{i}+k_{(i\mod l)}\right]\mod26$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Plaintext:  CRYPTOISSHORTFORCRYPTOGRAPHY 
\end_layout

\begin_layout Plain Layout

Key:        ABCDABCDABCDABCDABCDABCDABCD
\end_layout

\begin_layout Plain Layout

Ciphertext: CSASTPKVSIQUTGQUCSASTPIUAQJB
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
El método de Vigénere tiene estructura de grupo si y sólo si 
\begin_inset Formula $k_{1}$
\end_inset

 y 
\begin_inset Formula $k_{2}$
\end_inset

 son tales que la longitud de una es múltiplo de la longitud de la otra.
\end_layout

\begin_layout Itemize
Desventajas: 
\end_layout

\begin_deeper
\begin_layout Itemize
La naturaleza repetitiva de la clave.
 Si el criptoanalista descubre la longitud de la clave, se puede tratar
 al 
\emph on
cyphertext 
\emph default
como un conjunto de cifrados por CAESAR
\emph on
.

\emph default
 El test de Kasiski pueden ayudar a determinar la longitud de la clave.
\end_layout

\end_deeper
\begin_layout Subsection
Hill
\end_layout

\begin_layout Itemize
Sustitución poligráfica
\end_layout

\begin_layout Itemize
Tiene estructura de grupo
\end_layout

\begin_layout Itemize
\begin_inset Formula $k\in K=$
\end_inset

matrices de 
\begin_inset Formula $d\times d$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
elementos deben ser enteros entre 0 y 25 (el tamaño del alfabeto) puestos
 en forma aleatoria
\end_layout

\begin_layout Itemize
matriz debe ser inversible en aritmética módulo 26.
 
\begin_inset Formula $\left[\left(\det K\right)\mod26\right]=1$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\left|K\right|=26^{d^{2}}$
\end_inset


\end_layout

\begin_layout Itemize
Sea un mensaje 
\begin_inset Formula $m$
\end_inset

 con 
\begin_inset Formula $d$
\end_inset

 caracteres.
 A cada caracter de 
\begin_inset Formula $m$
\end_inset

 lo reemplazamos por su posición en el alfabeto.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{k}(m)=\left(K\cdot m\right)\mod26=c$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{k}(c)=\left[\left(K^{-1}\mod26\right)\cdot c\right]\mod26=m$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Criptoanálisis: 
\end_layout

\begin_deeper
\begin_layout Itemize
si 
\begin_inset Formula $d$
\end_inset

 es chica, ataque por fuerza bruta probando 
\begin_inset Formula $\left|K\right|$
\end_inset

 claves.
\end_layout

\begin_layout Itemize
si 
\begin_inset Formula $d$
\end_inset

 es grande, ataque por texto plano conocido (si se conocen 
\begin_inset Formula $d^{2}$
\end_inset

 textos planos y sus criptogramas, se puede armar un sistema de ecuaciones
 lineales y despejar los valores de la matriz 
\begin_inset Formula $K$
\end_inset

).
\end_layout

\end_deeper
\begin_layout Subsection
Playfair
\end_layout

\begin_layout Itemize
Sustitución monoalfabética de orden 2 (grupos de 2 caracteres siempre son
 encriptados de la misma forma)
\end_layout

\begin_layout Itemize
\begin_inset Formula $k\in K=$
\end_inset

matrices de 
\begin_inset Formula $5\times5$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
elementos deben ser las letras del alfabeto puestas en forma aleatoria (una
 posición de la matriz puede tener 2 letras)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\left|K\right|=26^{25}\approx2\times10^{35}$
\end_inset


\end_layout

\begin_layout Itemize
Encriptación: 
\end_layout

\begin_deeper
\begin_layout Itemize
Sea un mensaje 
\begin_inset Formula $M$
\end_inset

.
 Lo dividimos en grupos de 2 caracteres (
\begin_inset Formula $c_{1}$
\end_inset

 y 
\begin_inset Formula $c_{2}$
\end_inset

).
 
\end_layout

\begin_layout Itemize
A cada grupo le aplicamos la siguiente reglas:
\end_layout

\begin_deeper
\begin_layout Itemize
Si 
\begin_inset Formula $c_{1}=c_{2}$
\end_inset

, reemplazamos 
\begin_inset Formula $c_{2}$
\end_inset

 por una letra predeterminada (por ejemplo, 'X').
\end_layout

\begin_layout Itemize
Si 
\begin_inset Formula $c_{1},c_{2}$
\end_inset

 se encuentran en la misma fila de la matriz 
\begin_inset Formula $k$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Encriptar cada caracter con el caracter que está a la derecha del mismo
 en la matriz (si se termina la fila seguir en la de abajo).
\end_layout

\end_deeper
\begin_layout Itemize
Si 
\begin_inset Formula $c{}_{1},c_{2}$
\end_inset

 se encuentran en la misma columna de la matriz 
\begin_inset Formula $k$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Encriptar cada caracter con el caracter que está abajo del mismo en la matriz
 (si se termina la columna seguir en la de la derecha).
\end_layout

\end_deeper
\begin_layout Itemize
Si 
\begin_inset Formula $c_{1},c_{2}$
\end_inset

 no se encuentran en la misma fila ni en la misma columna de la matriz 
\begin_inset Formula $k$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Encriptar cada caracter con los caracteres que están en las esquinas del
 rectángulo formado por 
\begin_inset Formula $c1,c2$
\end_inset

, y en la misma fila que el caracter a encriptar.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Desencriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Ignorar la primera regla.
 En las reglas 2 y 3 hace shift arriba y a la izquierda en vez de abajo
 y a derecha.
 La regla 4 permanece igual.
 
\end_layout

\begin_layout Itemize
Al finalizar, borrar las 
\begin_inset Formula $X$
\end_inset

 sobrantes y localizar alguna 
\begin_inset Formula $I$
\end_inset

 que debe ser 
\begin_inset Formula $J$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Desventajas: 
\begin_inset Formula $D\left(E(M)\right)\neq M$
\end_inset

 porque dos letras iguales se encriptan como dos caracteres distintos.
\end_layout

\begin_layout Itemize
Criptoanálisis: 
\end_layout

\begin_deeper
\begin_layout Itemize
Análisis de frecuencias: analizar la frecuencia de aparición de los digramas
 y compararlas con los digramas más frecuentes del idioma en el cual se
 supone que se escribió el mensaje original.
\end_layout

\end_deeper
\begin_layout Subsection
DES (Data Encryption Standard)
\end_layout

\begin_layout Itemize
Cifrado de producto.
\end_layout

\begin_layout Itemize
Utiliza una clave de 56 bits (en realidad es de 64 bits, pero 8 bits son
 de paridad así que no los tenemos en cuenta).
\begin_inset Formula $\left|K\right|=2^{56}\approx7\times10^{16}$
\end_inset


\end_layout

\begin_layout Itemize
No tiene estructura de grupo.
\end_layout

\begin_layout Itemize
Fue creado por IBM, y modificada por NSA.
\end_layout

\begin_layout Itemize
En 1999 se logró romperlo en 1 día con una computadora valuada en U$S 100.000.
\end_layout

\begin_layout Itemize
Desventajas: 
\end_layout

\begin_deeper
\begin_layout Itemize
Tiene 4 claves débiles y 16 claves semi débiles.
\end_layout

\begin_layout Itemize
La clave es muy corta.
\end_layout

\end_deeper
\begin_layout Itemize
Encriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Entran 64 bits de 
\emph on
plaintext 
\emph default
y salen 64 bits de 
\emph on
cyphertext
\emph default
.
\end_layout

\begin_layout Itemize
Redes de Feistel:
\end_layout

\begin_deeper
\begin_layout Itemize
Dividir un bloque de longitud 
\begin_inset Formula $n$
\end_inset

 en dos mitades, 
\begin_inset Formula $L$
\end_inset

 y 
\begin_inset Formula $R$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L_{i}=\begin{cases}
R_{i-1} & \mbox{si }i<n\\
L_{i-1}\oplus f\left(R_{i-1},K_{i}\right) & \mbox{si }i=n
\end{cases}$
\end_inset

	
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{i}=\begin{cases}
L_{i-1}\oplus f\left(R_{i-1},K_{i}\right) & \mbox{si }i<n\\
R_{i-1} & \mbox{si }i=n
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/DES.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
DES
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Criptoanálisis: ataque por fuerza bruta.
\end_layout

\begin_layout Subsection
Triple-DES
\end_layout

\begin_layout Itemize
Triple DES con 3 claves independientes (
\begin_inset Formula $k_{1}\neq k_{2}\neq k_{3}$
\end_inset

) tiene una longitud de clave de 168 bits, pero debido al ataque  
\emph on
meet-in-the-middle
\emph default
, la seguridad efectiva es de 112 bits.
\end_layout

\begin_layout Itemize
Triple DES con 2 claves independientes (
\begin_inset Formula $k_{3}=k_{1}$
\end_inset

) tiene una longitud de clave de 112 bits, pero debido a los ataques de
 texto plano escogido o texto plano, la seguridad efectiva es de 80 bits.
\end_layout

\begin_deeper
\begin_layout Itemize
Este modo es más seguro que encriptando con DES 2 veces, porque protege
 ante ataques
\emph on
 meet-in-the-middle
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Es tres veces más lento que DES.
\end_layout

\begin_layout Itemize
Encripta bloques de 64 bits.
\end_layout

\begin_layout Itemize
Si se elige el modo 
\begin_inset Quotes eld
\end_inset

2 claves
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{k_{1},k_{2}}(m)=E_{k_{3}}\left(D_{k_{2}}\left(E_{k_{1}}(m)\right)\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{k_{1},k_{2}}(m)=D_{k_{3}}\left(E_{k_{2}}\left(D_{k_{1}}(m)\right)\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Criptoanálisis: ataque por fuerza bruta.
\end_layout

\begin_layout Subsection
AES (
\emph on
Advanced Encryption Standard
\emph default
)
\end_layout

\begin_layout Itemize
Tiene dos partes:
\end_layout

\begin_deeper
\begin_layout Itemize
Discreta: aplicar sustituciones y transposiciones
\end_layout

\begin_layout Itemize
Continua
\end_layout

\end_deeper
\begin_layout Itemize
Es el heredero moderno de DES.
\end_layout

\begin_layout Itemize
Fue diseñado en una competencia pública.
\end_layout

\begin_layout Itemize
Utiliza claves de 128, 192 o 256 bits.
\end_layout

\begin_layout Section
Modos de encriptación por bloques
\end_layout

\begin_layout Standard
Problema: utilizando un algoritmo con una clave de longitud 
\begin_inset Formula $l$
\end_inset

, ¿cómo encriptar un mensaje de longitud 
\begin_inset Formula $m>l$
\end_inset

?
\end_layout

\begin_layout Standard
Soluciones: dividir el mensaje en bloques de 
\begin_inset Formula $l$
\end_inset

 caracteres, y encriptar los bloques.
\end_layout

\begin_layout Itemize

\series bold
ECB
\series default
 (
\emph on
Electronic Code Block
\emph default
): cada bloque se encripta en forma independiente.
\end_layout

\begin_deeper
\begin_layout Itemize
Desventaja: si 
\begin_inset Formula $b_{1}$
\end_inset

 y 
\begin_inset Formula $b_{2}$
\end_inset

 son dos bloques idénticos, 
\begin_inset Formula $E\left(b_{1}\right)=E\left(b_{2}\right)$
\end_inset

.
 Con lo cual, no esconde bien los patrones del 
\emph on
plaintext
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Encriptacion
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	codigo n = encriptar (bloque n)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Desencriptacion
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	desencriptar (codigo n)
\end_layout

\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
CBC
\series default
 (
\emph on
Cipher Block Chaining
\emph default
): a cada bloque de 
\emph on
plaintext
\emph default
 se le aplica XOR con el bloque 
\emph on
cyphertext
\emph default
 anterior antes de ser encriptar.
 De esta manera, cada 
\emph on
cyphertext
\emph default
 depende de todos los 
\emph on
plaintext
\emph default
 anteriores.
 Para el primer bloque se usa un vector de inicialización.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Encriptacion
\end_layout

\begin_layout Plain Layout

codigo 0 = encriptar (bloque 0 XOR vector de inicializacion)
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	codigo n = encriptar (bloque n XOR codigo n-1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Desencriptacion
\end_layout

\begin_layout Plain Layout

bloque 0 = desencriptar (codigo 0) XOR vector de inicializacion
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	bloque n = desencriptar (codigo n) XOR codigo n-1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Desventajas: 
\end_layout

\begin_deeper
\begin_layout Itemize
La encriptación debe hacerse en forma secuencial; no se puede paralelizar.
\end_layout

\begin_layout Itemize
Desencriptar con el vector equivocado hará que el primer bloque de 
\emph on
plaintext 
\emph default
esté corrupto (pero el resto no).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
CFB
\series default
 (
\emph on
Chiper Feedback
\emph default
): similar a CBC.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Encriptacion
\end_layout

\begin_layout Plain Layout

codigo 0 = encriptar (vector de inicializacion) XOR bloque 0
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	codigo n = encriptar (codigo n-1) XOR (bloque n)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Desencriptacion
\end_layout

\begin_layout Plain Layout

bloque 0 = encriptar (vector de inicializacion) XOR codigo 0
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	bloque n = encriptar(codigo n-1) XOR codigo n
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
OFB
\series default
 (
\emph on
Output Feedback
\emph default
)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Encriptacion
\end_layout

\begin_layout Plain Layout

block cipher encryption = encriptar (vector de inicializacion)
\end_layout

\begin_layout Plain Layout

codigo 0 = block cipher encryption XOR bloque 0
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	block cipher encryption = encriptar (block cipher encryption)
\end_layout

\begin_layout Plain Layout

	codigo n = block cipher encryption XOR bloque n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Desencriptacion
\end_layout

\begin_layout Plain Layout

block cipher encryption = encriptar (vector de inicializacion)
\end_layout

\begin_layout Plain Layout

bloque 0 = block cipher encryption XOR codigo 0
\end_layout

\begin_layout Plain Layout

while true:
\end_layout

\begin_layout Plain Layout

	block cipher encryption = encriptar (block cipher encryption)
\end_layout

\begin_layout Plain Layout

	bloque n = block cipher encryption XOR codigo n
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Cifrado de flujo
\end_layout

\begin_layout Itemize
El emisor y el receptor tienen tiene una tira de bits (la misma) generadas
 aleatoriamente.
\end_layout

\begin_layout Itemize
Debe cumplirse que 
\begin_inset Formula $l(mensaje)=l(clave)$
\end_inset

.
\end_layout

\begin_layout Itemize
Es un método incondicionalmente seguro.
 Es el algoritmo de cifrado 
\begin_inset Quotes eld
\end_inset

perfecto
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\emph on
Encrypting two different random "plain texts" with the same "pad" is indistingui
shable from using two different random one time pads for encrypting the
 same plain text.
 
\end_layout

\begin_layout Itemize
Desventajas:
\end_layout

\begin_deeper
\begin_layout Itemize
Si el mensaje es muy largo, la clave también lo será.
\end_layout

\begin_layout Itemize
Hay que transmitir la clave por cada mensaje y por cada remitente.
\end_layout

\begin_layout Itemize
Dada la naturaleza determinista de las computadoras, generar una clave aleatoria
 es prácticamente imposible.
 Se deben utilizar mecanismos pseudoaleatorios, que cumplan tres propiedades:
\end_layout

\begin_deeper
\begin_layout Itemize
Cada bit de la clave no se debe poder predecir, aún sabiendo los bits anteriores.
\end_layout

\begin_layout Itemize
Debe pasar los tests estadistícos de aleatoriedad (chi cuadrado).
\end_layout

\begin_layout Itemize
Si se corre el generador dos veces, las salidas deben ser distintas.
\end_layout

\end_deeper
\begin_layout Itemize
No proporciona autenticación.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $E_{k}(m)=m\,\mbox{XOR}k$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{k}(m)=m\,\mbox{XOR}k$
\end_inset


\end_layout

\begin_layout Itemize
Criptoanálisis:
\end_layout

\begin_deeper
\begin_layout Itemize
Ataque por texto plano conocido o escogido no sirven porque las claves solo
 se utilizan para un solo mensaje, luego se descartan.
\end_layout

\begin_layout Itemize
Ataque por fuerza bruta no sirve porque solo generaría todos los mensajes
 que existen de esa longitud.
\end_layout

\begin_layout Itemize
Ataque por análisis de frecuencia no sirve porque el criptograma es aleatorio.
\end_layout

\end_deeper
\begin_layout Section
Ejemplos de criptosistemas de clave pública
\end_layout

\begin_layout Subsection
Knapsacks
\end_layout

\begin_layout Itemize
No provee autenticación.
\end_layout

\begin_layout Quotation

\emph on
Problema matemático de la mochila: se tiene una mochila con capacidad para
 
\begin_inset Formula $k$
\end_inset

 kilos.
 Se tienen 
\begin_inset Formula $n$
\end_inset

 objetos cuyos pesos son 
\begin_inset Formula $P=(p_{1},p_{2},\ldots,p_{n})$
\end_inset

.
 ¿Qué objetos seleccionamos para guardar en la mochila para que ésta quede
 llena?
\end_layout

\begin_layout Quotation

\emph on
Solución computacionalmente lenta: probar las 
\begin_inset Formula $2^{n}$
\end_inset

 combinaciones.
\end_layout

\begin_layout Standard

\series bold
Criptosistema de clave privada
\series default
:
\end_layout

\begin_layout Itemize
Encriptación:
\end_layout

\begin_deeper
\begin_layout Enumerate
La clave es 
\begin_inset Formula $K=P$
\end_inset

.
\end_layout

\begin_layout Enumerate
Dado un mensaje, lo pasamos a binario.
\end_layout

\begin_layout Enumerate
Para cada bloque de 
\begin_inset Formula $n$
\end_inset

 bits del mensaje:
\end_layout

\begin_deeper
\begin_layout Enumerate
Sea 
\begin_inset Formula $\alpha$
\end_inset

 el vector de bits del bloque.
\end_layout

\begin_layout Enumerate
Se calcula 
\begin_inset Formula $S=\sum_{i=1}^{n}\alpha_{i}\cdot K_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S$
\end_inset

 es la encriptación del bloque.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Desencriptación: dado el código 
\begin_inset Formula $S$
\end_inset

, y la clave 
\begin_inset Formula $K$
\end_inset

, hay que resolver el problema de la mochila (hallar los 
\begin_inset Formula $\alpha_{i}$
\end_inset

 tal que 
\begin_inset Formula $S=\sum_{i=1}^{n}\alpha_{i}\cdot K_{i}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
Criptosistema de clave pública
\series default
: se encripta con la clave pública y se desencripta con la clave privada.
\end_layout

\begin_layout Itemize
Generación de claves:
\end_layout

\begin_deeper
\begin_layout Itemize
Elegir un vector 
\begin_inset Formula $V$
\end_inset

 super incrementante (
\begin_inset Formula $V_{i}>\sum_{j=0}^{i-1}V_{j}$
\end_inset

 para todo 
\begin_inset Formula $i$
\end_inset

)
\end_layout

\begin_layout Itemize
Elegir dos números 
\begin_inset Formula $t$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

multiplicador
\begin_inset Quotes erd
\end_inset

) y 
\begin_inset Formula $m$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

módulo
\begin_inset Quotes erd
\end_inset

) tal que 
\begin_inset Formula $t$
\end_inset

 y 
\begin_inset Formula $m$
\end_inset

 no tengan factores en común (i.e.
 deben ser relativamente primos)
\end_layout

\begin_layout Itemize
Calcular 
\begin_inset Formula $t'$
\end_inset

, el inverso multiplicativo de 
\begin_inset Formula $t$
\end_inset

 usando aritmética módulo 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Itemize
La clave 
\series bold
privada
\series default
 es 
\begin_inset Formula $<t',m>$
\end_inset

.
\end_layout

\begin_layout Itemize
Obtener el vector 
\begin_inset Formula $V'=(p_{i}\times t)\mod m$
\end_inset

.
 
\begin_inset Formula $V'$
\end_inset

 
\series bold
no
\series default
 es super incrementante.
 Esta es la clave 
\series bold
pública
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
Encriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Dado un mensaje con 
\begin_inset Formula $l$
\end_inset

 caracteres, lo pasamos a binario.
\end_layout

\begin_layout Itemize
Para cada bloque de 
\begin_inset Formula $n$
\end_inset

 bits del mensaje:
\end_layout

\begin_deeper
\begin_layout Enumerate
Sea 
\begin_inset Formula $\alpha$
\end_inset

 el vector de bits del bloque.
\end_layout

\begin_layout Enumerate
Se calcula 
\begin_inset Formula $S=\sum_{i=1}^{n}\alpha_{i}\cdot V'_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S$
\end_inset

 es la encriptación del bloque.
\end_layout

\end_deeper
\begin_layout Itemize
La encriptación del mensaje resulta 
\begin_inset Formula $(S_{1},S_{2},\ldots,S_{l})$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Desencriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Dado el código 
\begin_inset Formula $(S_{1},S_{2},\ldots,S_{l})$
\end_inset

, el vector público 
\begin_inset Formula $V'$
\end_inset

 y la clave privada 
\begin_inset Formula $<t',m>$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Obtener el vector 
\begin_inset Formula $A$
\end_inset

 haciendo 
\begin_inset Formula $A_{i}=\left(S_{i}\times t'\right)\mod m$
\end_inset


\end_layout

\begin_layout Itemize
Obtener el vector 
\begin_inset Formula $V$
\end_inset

 haciendo 
\begin_inset Formula $V{}_{i}=\left(V'_{i}\times t'\right)\mod m$
\end_inset


\end_layout

\begin_layout Itemize
Resolver el problema de la mochila (hallar los 
\begin_inset Formula $\alpha_{i}$
\end_inset

 tales que 
\begin_inset Formula $A_{i}=\sum_{i=1}^{nl}\alpha\cdot V_{i}$
\end_inset

).
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
RSA (Rivest - Shamir - Adleman)
\end_layout

\begin_layout Itemize
Provee confidencialidad (se encripta con la pública y se desencripta con
 la privada).
\end_layout

\begin_layout Quotation

\emph on
Problema: se tiene un número 
\begin_inset Formula $k$
\end_inset

 que es el producto de dos números primos 
\begin_inset Formula $p$
\end_inset

 y 
\begin_inset Formula $q$
\end_inset

 de aproximadamente 100 dígitos cada uno (desconocidos).
 ¿Cómo obtener los números 
\begin_inset Formula $p$
\end_inset

 y 
\begin_inset Formula $q$
\end_inset

 a partir de 
\begin_inset Formula $k$
\end_inset

?
\end_layout

\begin_layout Quotation

\emph on
Solución computacionalmente lenta: probar todas las combinaciones de 
\begin_inset Formula $p$
\end_inset

 y 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Standard
Generación de claves:
\end_layout

\begin_layout Itemize
Elegir dos números primos 
\begin_inset Formula $p$
\end_inset

 y 
\begin_inset Formula $q$
\end_inset

 distintos, muy grandes, de tamaño en bits similar.
 
\end_layout

\begin_layout Itemize
Calcular:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n=p\times q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\phi(n)=(p-1)\times(q-1)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Elegir un número 
\begin_inset Formula $e$
\end_inset

 tal que 
\begin_inset Formula $1<e<\phi$
\end_inset

 y 
\begin_inset Formula $mcd(e,\phi(n))=1$
\end_inset

 (es decir, 
\begin_inset Formula $e$
\end_inset

 y 
\begin_inset Formula $\phi(n)$
\end_inset

 son coprimos).
\end_layout

\begin_layout Itemize
Calcular 
\begin_inset Formula $d$
\end_inset

 como 
\begin_inset Formula $d^{-1}\equiv e(\mod\phi(n))$
\end_inset

.
 Es decir, 
\begin_inset Formula $d$
\end_inset

 es el inverso multiplicativo de 
\begin_inset Formula $e$
\end_inset

 en aritmética módulo 
\begin_inset Formula $\phi(n)$
\end_inset

.
 Utilizar el algoritmo de Euclides.
\end_layout

\begin_layout Itemize
La 
\series bold
clave pública 
\series default
es el par 
\begin_inset Formula $(n,e)$
\end_inset

.
\end_layout

\begin_layout Itemize
La 
\series bold
clave privada
\series default
 es el par 
\begin_inset Formula $(\phi,d)$
\end_inset

.
\end_layout

\begin_layout Standard
Encriptación:
\end_layout

\begin_layout Itemize
Pasar el mensaje a binario.
\end_layout

\begin_layout Itemize
Dividir el mensaje en bloques de tamaño 
\begin_inset Formula $i$
\end_inset

 (
\begin_inset Formula $10^{i-1}<n<10^{i}$
\end_inset

)
\end_layout

\begin_layout Itemize
Para cada bloque 
\begin_inset Formula $b$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Calcular 
\begin_inset Formula $c=(b^{e})\mod n$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Para calcular esto rápidamente, las computadoras usan exponenciación por
 cuadrados.
 Cualquier número 
\begin_inset Formula $x$
\end_inset

 puede representarse como 
\begin_inset Formula $x=\sum_{i}\alpha_{i}2^{i}$
\end_inset

.
 Entonces 
\begin_inset Formula $\left(a^{b}\mod q\right)$
\end_inset

 implica hacer 
\begin_inset Formula $a_{i}=a_{i-1}^{2}$
\end_inset

 tantas veces como bits tenga 
\begin_inset Formula $b$
\end_inset

.
 El resultado es 
\begin_inset Formula $\prod_{i}\mbox{bit}_{i}(b)a_{i}\mod q$
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Desencriptación:
\end_layout

\begin_layout Itemize
Para cada bloque 
\begin_inset Formula $c$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Obtener 
\begin_inset Formula $b=(c^{d})\mod n$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Desventajas:
\end_layout

\begin_layout Itemize
El criptograma resultante es de tamaño fijo.
\end_layout

\begin_layout Itemize
Es lento.
\end_layout

\begin_layout Quote

\emph on
Suppose Alice uses Bob's public key to send him an encrypted message.
 In the message, she can claim to be Alice but Bob has no way of verifying
 that the message was actually from Alice since anyone can use Bob's public
 key to send him encrypted messages.
 In order to verify the origin of a message, 
\series bold
RSA can also be used to sign a message
\series default
.
\end_layout

\begin_layout Standard
Criptoanálisis:
\end_layout

\begin_layout Itemize
Ataque por fuerza bruta no sirve porque habría que probar una cantidad enorme
 de combinaciones de números.
\end_layout

\begin_layout Section
Criptoanálisis
\end_layout

\begin_layout Standard
Tipos de ataques:
\end_layout

\begin_layout Itemize

\series bold
Por fuerza bruta
\series default
: dado 
\begin_inset Formula $C$
\end_inset

, probar el espacio 
\begin_inset Formula $K$
\end_inset

 de claves para obtener 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
\emph on
Shoulder surfing
\series default
\emph default
: utilizando 
\emph on
keyloggers
\emph default
, cámaras, etc.
\end_layout

\begin_layout Itemize

\series bold
Caballos de Troya
\series default
: programa que cada vez que se ejecuta, le pide la contraseña al usuario,
 y la graba en un archivo.
\end_layout

\begin_layout Itemize

\series bold
Ingeniería social
\series default
: es el método más útil.
 Consiste en conseguir que la persona que conoce la clave privada nos la
 diga.
\end_layout

\begin_layout Itemize

\series bold
Ataque por texto plano
\series default
: el atacante conoce textos planos y sus correspondientes criptogramas,
 pero no conoce 
\begin_inset Formula $E$
\end_inset

.
 Quiere descubrir la clave.
\end_layout

\begin_layout Itemize

\series bold
Ataque por texto plano escogido
\series default
: el atacante puede encriptar textos planos que él escogió y obtener sus
 correspondientes criptogramas.
 Quiere descubrir la clave.
\end_layout

\begin_deeper
\begin_layout Itemize
Ataque 
\emph on
meet-in-the-middle
\emph default
: afecta solo a cifrados de producto (DES, 3DES, etc.).
 Consiste en encriptar de un lado, desencriptar del otro, y matchear los
 resultados intermedios.
\end_layout

\begin_deeper
\begin_layout Standard
El criptoanalista conoce 
\begin_inset Formula $M_{1},C_{1}$
\end_inset

 y 
\begin_inset Formula $M_{2},C_{2}$
\end_inset

, y quiere descubrir 
\begin_inset Formula $k_{1}$
\end_inset

 y 
\begin_inset Formula $k_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
C_{1} & = & E_{k_{2}}\left(E_{k_{1}}(M_{1})\right)\\
C_{2} & = & E_{k_{2}}\left(E_{k_{1}}(M_{2})\right)\\
D_{k_{2}}(C_{1}) & = & E_{k_{1}}\left(C_{1}\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Enumerate
Para cada posible 
\begin_inset Formula $j$
\end_inset

, calcular 
\begin_inset Formula $E_{j}\left(M_{1}\right)$
\end_inset

 y guardar en memoria el par 
\begin_inset Formula $j,E_{j}\left(M_{1}\right)$
\end_inset

 en una tabla de hash.
\end_layout

\begin_layout Enumerate
Para cada posible 
\begin_inset Formula $k$
\end_inset

, calcular 
\begin_inset Formula $D_{k}\left(C_{1}\right)$
\end_inset

 y buscar este resultado en la memoria.
 Si se lo encuentra, es posible que 
\begin_inset Formula $k=k_{2}$
\end_inset

 y que 
\begin_inset Formula $j=k_{1}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $E_{k}\left(E_{j}(M_{2})\right)=C_{2}$
\end_inset

, es muy probable que descubierto 
\begin_inset Formula $k_{1}$
\end_inset

y 
\begin_inset Formula $k_{2}$
\end_inset

.
 Si no son iguales, tendrá que seguir buscando coincidencias.
\end_layout

\begin_layout Standard
Este ataque logra disminuir la cantidad de intentos necesarios de 
\begin_inset Formula $2^{2n}$
\end_inset

 a 
\begin_inset Formula $2^{n+1}$
\end_inset

, pero requiere muchísima memoria (
\begin_inset Formula $2^{56}$
\end_inset

 bloques de memoria de 64 bits).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Ataque por criptograma
\series default
: el atacante conoce criptogramas generados por el criptosistema, e intenta
 recuperar los mensajes asociados (no la clave).
\end_layout

\begin_layout Itemize

\series bold
Análisis de frecuencias
\series default
: estudiar la frecuencia con que aparecen los distintos símbolos en un lenguaje
 determinado, y compararla con la frecuencia de los símbolos de los criptogramas.
\end_layout

\begin_layout Itemize

\series bold
Ataque del intermediario
\series default
 (
\emph on
man-in-the-middle
\emph default
): solo es posible en criptosistemas asimétricos y en medios inseguros.
\end_layout

\begin_deeper
\begin_layout Enumerate
Alice le envía un mensaje a Bob, el cual es interceptado por Mallory.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice "Hi Bob, it's Alice.
 Give me your key"--> Mallory Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Mallory le envía este mensaje a Bob; Bob no sabe que en realidad el mensaje
 provino de Mallory.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice Mallory "Hi Bob, it's Alice.
 Give me your key"--> Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Bob responde con su clave pública.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice Mallory <--[Bob's_key] Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Mallory reemplaza la clave de Bob con la suya, y se la envía a Alice, haciéndole
 creer que es la clave de Bob.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice <--[Mallory's_key] Mallory Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Alice encripta un mensaje con lo que cree es la clave de Bob.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice "Meet me at the bus stop!"[encrypted with Mallory's key]--> Mallory
 Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Sin embargo, como en realidad fue encriptado con la clave de Mallory, Mallory
 puede desencriptarla, leerla, modificarla si quiere, reencriptarla con
 la clave de Bob, y enviársela a Bob.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Alice Mallory "Meet me at 22nd Ave!"[encrypted with Bob's key]--> Bob 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Bob cree que este mensaje significa que ha establecido una comunicación
 segura con Alice.
 
\end_layout

\begin_layout Standard
Este ataque se puede evitar con el uso de certificados digitales que prueben
 la autenticidad de una clave pública.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Análisis diferencial
\series default
: dados dos mensajes 
\begin_inset Formula $m_{1}$
\end_inset

 y 
\begin_inset Formula $m_{2}$
\end_inset

 con un bit de diferencia, estudiar las diferencias entre 
\begin_inset Formula $E_{k}(m_{1})$
\end_inset

 y 
\begin_inset Formula $E_{k}(m_{2})$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Ataque por replay
\series default
: 
\emph on
a form of network attack in which a valid data transmission is maliciously
 or fraudulently repeated or delayed.
 This is carried out either by the originator or by an adversary who intercepts
 the data and retransmits it.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
Suppose Alice wants to prove her identity to Bob.
 Bob requests her password as proof of identity, which Alice dutifully provides
 (possibly after some transformation like a hash function); meanwhile, Mallory
 is eavesdropping on the conversation and keeps the password (or the hash).
 After the interchange is over, Mallory (posing as Alice) connects to Bob;
 when asked for a proof of identity, Mallory sends Alice's password (or
 hash) read from the last session, which Bob accepts.
\end_layout

\begin_layout Itemize
Soluciones:
\end_layout

\begin_deeper
\begin_layout Itemize
Uso de claves de sesión generados por un algoritmo aleatorio.
\end_layout

\begin_layout Itemize
Uso de claves desechables.
\end_layout

\begin_layout Itemize
Timestamping, pero requiere de sincronización entre las partes.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Resultados de un ataque según la severidad del mismo (en orden decreciente):
\end_layout

\begin_layout Enumerate
Ruptura total: el atacante descubre la clave.
\end_layout

\begin_layout Enumerate
Deducción global: el atacante descubre un algoritmo funcionalmente equivalente
 al cifrado y descifrado de mensajes.
\end_layout

\begin_layout Enumerate
Deducción local: el atacante descubre el texto plano de un criptograma.
\end_layout

\begin_layout Enumerate
Deducción de información: el atacante recibe alguna información acerca del
 texto plano o de la calve.
\end_layout

\begin_layout Enumerate
Distinción del algoritmo: el atacante descubre un patrón en los criptogramas.
\end_layout

\begin_layout Section
Firma digital y certificados digitales
\end_layout

\begin_layout Standard
Una firma digital es un mecanismo criptográfico que permite al receptor
 de un mensaje firmado digitalmente determinar la entidad originadora de
 dicho mensaje (autenticación de origen y no repudio).
\end_layout

\begin_layout Standard
Las firmas digitales suelen incluir 
\emph on
timestamps
\emph default
, para impedir que alguien las reutilice.
\end_layout

\begin_layout Standard
Propiedades necesarias:
\end_layout

\begin_layout Enumerate
Únicas: Las firmas deben poder ser generadas solamente por el firmante.
\end_layout

\begin_layout Enumerate
Infalsificables: Para falsificar una firma digital el atacante tiene que
 resolver problemas matemáticos de una complejidad muy elevada, es decir,
 las firmas han de ser computacionalmente seguras.
 Por tanto la firma debe depender del mensaje en sí.
 
\end_layout

\begin_layout Enumerate
Verificables: Las firmas deben ser fácilmente verificables por los receptores
 de las mismas y, si ello es necesario, también por los jueces o autoridades
 competentes.
 
\end_layout

\begin_layout Enumerate
Innegables: El firmante no debe ser capaz de negar su propia firma.
 
\end_layout

\begin_layout Enumerate
Viables: Las firmas han de ser fáciles de generar por parte del firmante.
\end_layout

\begin_layout Subsection
Firma digital simétrica
\end_layout

\begin_layout Itemize
Provee confidencialidad, autenticación y no repudio.
\end_layout

\begin_layout Itemize
Es un protocolo arbitrado: debe existir una autoridad que almacene las claves
 privadas de todos (el 
\emph on
big brother
\emph default
).
 Esta autoridad debe tener su propia clave privada.
\end_layout

\begin_layout Itemize
Encriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Alice encripta 
\begin_inset Formula $m$
\end_inset

 mediante 
\begin_inset Formula $E_{k_{privada_{Alice}}}(m)=c$
\end_inset

 .
 Le envía al 
\emph on
big brother 
\series bold
\emph default

\begin_inset Formula $c$
\end_inset


\series default
, junto con el nombre de Bob.
\end_layout

\begin_layout Itemize
El 
\emph on
big brother
\emph default
 desencripta 
\begin_inset Formula $c$
\end_inset

 mediante 
\begin_inset Formula $D_{k_{privada_{Alice}}}(c)=m$
\end_inset

.
 Encripta 
\begin_inset Formula $m$
\end_inset

 con la clave privada del Bob, 
\begin_inset Formula 
\[
E_{k_{privada_{Bob}}}\left(Bob,m,\underset{\mbox{garantiza no repudio de Alice}}{\underbrace{E_{k_{privada_{bigbrother}}}\left(Bob,m\right)}}\right)
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
y se lo envía a Bob.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Desencriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
Bob desencripta lo que le envió el
\series bold
\emph on
 
\series default
big brother 
\emph default
con su clave privada.
 
\end_layout

\end_deeper
\begin_layout Itemize
Desventajas:
\end_layout

\begin_deeper
\begin_layout Itemize
Todo el sistema depende del buen funcionamiento del 
\emph on
big brother
\emph default
.
\end_layout

\end_deeper
\begin_layout Subsection
Firma digital asimétrica
\end_layout

\begin_layout Itemize
Provee autenticación y no repudio (solo el emisor puede firmar el mensaje,
 pero cualquiera puede verificar la firma).
\end_layout

\begin_layout Itemize
Encriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
El emisor desencripta 
\begin_inset Formula $m$
\end_inset

 con su clave privada.
\end_layout

\begin_layout Itemize
El emisor encripta 
\begin_inset Formula $m$
\end_inset

 con la clave pública del receptor.
\end_layout

\end_deeper
\begin_layout Itemize
Desencriptación:
\end_layout

\begin_deeper
\begin_layout Itemize
El receptor desencripta 
\begin_inset Formula $m$
\end_inset

 con su clave privada.
\end_layout

\begin_layout Itemize
El receptor encripta 
\begin_inset Formula $m$
\end_inset

 con la clave pública del emisor.
\end_layout

\end_deeper
\begin_layout Itemize
Desventajas:
\end_layout

\begin_deeper
\begin_layout Itemize
Es lento.
\end_layout

\end_deeper
\begin_layout Subsection
Firma digital con 
\emph on
message digests
\end_layout

\begin_layout Itemize
Para lograr integridad de las transmisiones.
\end_layout

\begin_layout Itemize
Se utiliza una función de hash para hashear el documento
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Una función de hash no se puede utilizar para encriptar, porque nadie podría
 desencriptarlo.
\end_layout

\end_inset

.
 La firma consiste en encriptar el hash, que es mucho más rápido que el
 caso anterior, que hay que desencriptar y encriptar.
\end_layout

\begin_deeper
\begin_layout Itemize
Características de la función de hashing 
\begin_inset Formula $f$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Dado 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $f(x)$
\end_inset

 es fácil de calcular.
\end_layout

\begin_layout Itemize
Dado 
\begin_inset Formula $f(x)$
\end_inset

, 
\begin_inset Formula $x$
\end_inset

 es muy difícil de calcular.
\end_layout

\begin_layout Itemize
Dado 
\begin_inset Formula $x$
\end_inset

, es difícil obtener un 
\begin_inset Formula $x'$
\end_inset

 tal que 
\begin_inset Formula $f(x)=f(x')$
\end_inset

.
\end_layout

\begin_layout Itemize
Si le cambiamos un bit a 
\begin_inset Formula $x$
\end_inset

 para obtener 
\begin_inset Formula $\widetilde{x}$
\end_inset

, 
\begin_inset Formula $f\left(\widetilde{x}\right)$
\end_inset

 será muy distinta a 
\begin_inset Formula $f(x)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(x)$
\end_inset

 tiene longitud fija (128 o 256 bits).
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Firma digital con resumen que 
\series bold
no 
\series default
brinda confidencialidad:
\end_layout

\begin_layout Itemize
Provee autenticación, no repudio, integridad.
\end_layout

\begin_layout Itemize
Emisión:
\end_layout

\begin_deeper
\begin_layout Enumerate
Alice aplica la función resumen al mensaje, obteniendo 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alice desencripta 
\begin_inset Formula $md$
\end_inset

 con su clave privada: 
\begin_inset Formula $D_{k_{priv_{Alice}}}(md)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alice envía 
\begin_inset Formula $m+D_{k_{priv_{Alice}}}(md)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Recepción:
\end_layout

\begin_deeper
\begin_layout Enumerate
Bob encripta 
\begin_inset Formula $D_{k_{priv_{Alice}}}(md)$
\end_inset

 con la clave pública del Alice obteniendo 
\begin_inset Formula $m$
\end_inset

 y 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
Bob compara 
\begin_inset Formula $MD(m)=md$
\end_inset

.
 Si son iguales, sabe que el emisor es quien dice ser, y además que el mensaje
 no fue modificado en tránsito.
\end_layout

\end_deeper
\begin_layout Standard
Firma digital con resumen que 
\series bold
sí 
\series default
brinda confidencialidad:
\end_layout

\begin_layout Itemize
Provee confidencialidad, autenticación, no repudio e integridad.
\end_layout

\begin_layout Itemize
La encriptación se aplica después de la firma, y se debe encriptar tanto
 la firma como el mensaje final (mensaje + firma).
 Es como enviar una carta por correo: hay que firmar tanto la carta como
 el sobre.
\end_layout

\begin_layout Itemize
Emisión:
\end_layout

\begin_deeper
\begin_layout Enumerate
Alice aplica la función resumen a 
\begin_inset Formula $m$
\end_inset

, obteniendo 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alice encripta 
\begin_inset Formula $md$
\end_inset

 con su clave privada, obteniendo 
\begin_inset Formula $E_{k_{priv_{Alice}}}(md)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alicer encripta el mensaje 
\begin_inset Formula $m$
\end_inset

 y lo anterior con la clave pública de Bob.
 Obtiene 
\begin_inset Formula $E_{k_{pub_{Bob}}}\left(m+E_{k_{priv_{Alice}}}(md)\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Recepción:
\end_layout

\begin_deeper
\begin_layout Enumerate
Bob desencripta lo recibido con su clave privada.
 Obtiene 
\begin_inset Formula $m+E_{k_{priv_{Alice}}}(md)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Bob desencripta la segunda parte con la clave pública de Alice, obteniendo
 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
Compara 
\begin_inset Formula $MD(m)=md$
\end_inset

.
 Si son iguales, sabe que el emisor es quien dice ser, y además que el mensaje
 no fue modificado en tránsito.
\end_layout

\end_deeper
\begin_layout Subsection
Certificados digitales
\end_layout

\begin_layout Standard
El objetivo de un certificado digital es relacionar inequívocamente una
 persona con su clave pública.
 Si la clave no estuviese certificada, no podría asegurar autenticación
 o no repudio, a menos que hubiesen sido intercambiadas personalmente.
 
\end_layout

\begin_layout Itemize
Certificación:
\end_layout

\begin_deeper
\begin_layout Enumerate
Se le aplica la función resumen a 
\begin_inset Quotes eld
\end_inset

datos de la persona + clave pública de la persona
\begin_inset Quotes erd
\end_inset

, obteniendo 
\begin_inset Formula $md(persona+k_{pub_{persona}})$
\end_inset

.
\end_layout

\begin_layout Enumerate
La autoridad certificante recibe 
\begin_inset Formula $md(persona+k_{pub_{persona}}).$
\end_inset

 La encripta con su clave privada y se genera 
\begin_inset Formula $E_{k_{priv_{autoridad}}}\left(md(persona+k_{pub_{persona}})\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
El certificado digital es: 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $persona+k_{pub_{persona}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{k_{priv_{autoridad}}}\left(md(persona+k_{pub_{persona}})\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Verificación:
\end_layout

\begin_deeper
\begin_layout Enumerate
Se desencripta 
\begin_inset Formula $E_{k_{priv_{autoridad}}}\left(md(persona+k_{pub_{persona}})\right)$
\end_inset

 con la clave pública de la autoridad certificante.
 Se obtiene 
\begin_inset Formula $md(persona+k_{pub_{persona}})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Se calcula la función resumen de 
\begin_inset Formula $persona+k_{pub_{persona}}$
\end_inset

, y se compara con lo anterior.
 Si son iguales, la firma es auténtica.
\end_layout

\end_deeper
\begin_layout Section
Protocolos criptográficos
\end_layout

\begin_layout Standard

\series bold
Protocolo
\series default
: conjunto finito de pasos que deben realizar las partes involucradas para
 llevar a cabo un objetivo.
 El mismo debe ser de previo conocimiento de las partes participantes.
 Además debe ser completo (no existen situaciones que no abarque) y no ambiguo
 (para cada situación un único resultado).
 
\end_layout

\begin_layout Standard
En criptografía se utilizan protocolos para impedir o detectar fraudes y/o
 que otras partes intercepten la comunicación.
\end_layout

\begin_layout Standard
Los protocolos pueden ser:
\end_layout

\begin_layout Itemize

\series bold
Arbitrados
\series default
: existe una tercera parte confiable y neutral que controla que las 2 partes
 cumplan el protocolo.
\end_layout

\begin_layout Itemize

\series bold
Adjudicados
\series default
: como el anterior, pero no está controlando todo el tiempo.
 Sólo se lo 
\begin_inset Quotes eld
\end_inset

llama
\begin_inset Quotes erd
\end_inset

 para que determine si un protocolo fue ejecutado de forma justa.
\end_layout

\begin_layout Itemize

\series bold
Autosuficientes
\series default
: no existen terceras partes.
\end_layout

\begin_layout Subsection
Kerberos
\end_layout

\begin_layout Itemize
Provee autenticación.
\end_layout

\begin_layout Itemize
Alice (cliente) y Bob (servidor) comparten la clave con Authentication Server.
\end_layout

\begin_layout Itemize
La mayor parte del trabajo lo hace Alice.
\end_layout

\begin_layout Itemize
Alice quiere generar una clave de sesión para comunicarse con Bob.
\end_layout

\begin_layout Enumerate
Alice le envía un mensaje a Authentication Server con su nombre, y un mensaje
 encriptado con la clave privada de Alice (éste tiene un período de validez).
\end_layout

\begin_layout Enumerate

\series bold
Authentication Server
\series default
 trata de desencriptar el mensaje con la clave privada de Alice (la cual
 posee).
 Si lo logra, la autenticación es correcta.
\end_layout

\begin_layout Enumerate

\series bold
Authentication Server
\series default
 genera un 
\series bold
TGT
\series default
 (
\emph on
Ticket Granting Ticket
\emph default
) con un 
\emph on
timestamp
\emph default
, una vida útil, una clave de sesión aleatoria 
\begin_inset Formula $K_{1}$
\end_inset

, y la identidad de 
\series bold
Alice
\series default
.
 La encripta con la clave de 
\series bold
Ticket Granting Server
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Authentication Server
\series default
 genera un mensaje con la clave de sesión 
\begin_inset Formula $K_{1}$
\end_inset

.
 La encripta con la clave de 
\series bold
Alice
\series default
.
\end_layout

\begin_layout Standard
Envía ambas cosas a Alice.
\end_layout

\end_deeper
\begin_layout Enumerate
Alice le envía a 
\series bold
Ticket Granting Server
\series default
 el TGT junto con el nombre de 
\series bold
Bob
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
Alice le envía a 
\series bold
Ticket Granting Server
\series default
 el authenticator (cliente + timestamp) encriptado con la clave de sesión
 
\begin_inset Formula $K_{1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Ticket Granting Server
\series default
 le envía un Ticket a Alice:
\end_layout

\begin_deeper
\begin_layout Enumerate
Nombre de 
\series bold
Bob
\series default
,
\end_layout

\begin_layout Enumerate
Mensaje que contiene el nombre de 
\series bold
Alice
\series default
, la validez, y la clave de sesión 
\begin_inset Formula $K_{2}$
\end_inset

, encriptados con la clave de 
\series bold
Bob
\series default
.
\end_layout

\begin_layout Standard

\series bold
Ticket Granting Server
\series default
 envía otro mensaje a Alice: la clave de sesión 
\begin_inset Formula $K_{2}$
\end_inset

 para que pueda comunicarse con el servidor.
 Esta está encriptada con la clave 
\begin_inset Formula $K_{1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Alice le envía el Ticket a Bob.
\end_layout

\begin_deeper
\begin_layout Standard
Alice le envía un 
\series bold
authenticator
\series default
 al servidor (cliente + timestamp) encriptado con la clave 
\begin_inset Formula $K_{2}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Bob genera un mensaje con el 
\emph on
timestamp+1
\emph default
, lo encripta con 
\begin_inset Formula $K_{2}$
\end_inset

, y se lo envía a Alice.
 Esto se hace para evitar el ataque 
\emph on
man-in-the-middle
\emph default
.
\end_layout

\begin_layout Standard
Los 
\emph on
tickets
\emph default
 son reutilizables (por 8 horas).
\end_layout

\begin_layout Standard
Los 
\emph on
authenticators
\emph default
 tienen un tiempo de duración corto.
\end_layout

\begin_layout Standard
Desventajas:
\end_layout

\begin_layout Itemize
Se depende de Authentication Server.
\end_layout

\begin_layout Itemize
Los relojes de todos deben estar sincronizados.
\end_layout

\begin_layout Subsection
PGP
\end_layout

\begin_layout Itemize
Algoritmo híbrido.
\end_layout

\begin_layout Itemize
Trabaja con RSA con claves de 256, 512 y 1024 bits.
\end_layout

\begin_layout Standard
PGP emisión:
\end_layout

\begin_layout Enumerate
El emisor aplica una función de hash al mensaje, obteniendo 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
El emisor desencripta 
\begin_inset Formula $md$
\end_inset

 con su clave privada, obteniendo 
\begin_inset Formula $D_{k_{priv_{emisor}}}\left(md\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
El emisor comprime 
\begin_inset Formula $m+D_{k_{priv_{emisor}}}\left(md\right)$
\end_inset

 y obtiene 
\begin_inset Formula $C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]$
\end_inset


\end_layout

\begin_layout Enumerate
El emisor encripta 
\begin_inset Formula $C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]$
\end_inset

 con la 
\series bold
clave de sesión
\series default
 (clave desechable, generada mediante un algoritmo pseudoaleatorio que utiliza
 tipeos de teclado o movimientos de mouse por parte del usuario) obteniendo
 
\begin_inset Formula $E_{k_{sesion}}\left(C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
El emisor encripta la clave de sesión con la clave pública del receptor,
 obteniendo 
\begin_inset Formula $E_{k_{pub_{emisor}}}\left(k_{sesion}\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
El emisor envía 
\begin_inset Formula $E_{k_{sesion}}\left(C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]\right)+E_{k_{pub_{emisor}}}\left(k_{sesion}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
PGP recepción:
\end_layout

\begin_layout Enumerate
El receptor desencripta 
\begin_inset Formula $E_{k_{pub_{emisor}}}\left(k_{sesion}\right)$
\end_inset

 con su clave privada, y obtiene la clave de sesión.
\end_layout

\begin_layout Enumerate
El receptor desencripta 
\begin_inset Formula $E_{k_{sesion}}\left(C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]\right)$
\end_inset

 con la clave de sesión que obtuvo en el paso anterior, y obtiene 
\begin_inset Formula $C\left[m+D_{k_{priv_{emisor}}}\left(md\right)\right]$
\end_inset

.
\end_layout

\begin_layout Enumerate
El receptor descomprime lo anterior y obtiene 
\begin_inset Formula $m+D_{k_{priv_{emisor}}}\left(md\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
El receptor encripta 
\begin_inset Formula $D_{k_{priv_{emisor}}}\left(md\right)$
\end_inset

 con la clave pública del emisor y obtiene 
\begin_inset Formula $md$
\end_inset

.
\end_layout

\begin_layout Enumerate
Ahora que el receptor tiene 
\begin_inset Formula $m$
\end_inset

 y 
\begin_inset Formula $md$
\end_inset

: si 
\begin_inset Formula $MD(m)=md$
\end_inset

, entonces sabe que el mensaje es auténtico.
 Si no son iguales, entonces o bien el mensaje fue modificado en tránsito,
 o bien el emisor no es quien dice ser.
\end_layout

\end_body
\end_document
